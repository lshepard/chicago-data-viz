'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * The abstract class VbChart contains methods and properties common
 * to all the different charts (treemap, linechart, metric, etc).
 */
var VbChart = function () {

    // Chart
    function VbChart($div, data, config) {
        var _this = this;

        _classCallCheck(this, VbChart);

        // Properties of the chart are specified as HTML data attributes.
        this.atts = this.removeVbPrefixesOnAttributes($div.data());

        // Set the name of the dataset.
        if (typeof this.atts.name !== 'undefined') {
            data.name = this.atts.name;
        } else {
            data.name = this.toTitleCase(this.atts.data.toString());
        }

        // If this is a comparison chart, then data is an array.
        if (data.constructor !== Array) {
            // Not a comparison chart.
            if (typeof this.atts.node !== 'undefined') {
                data = this.getNodeByLevels(this.atts.node, data);
            }
        } else {
            // Comparison chart.
            if (typeof this.atts.node !== 'undefined') {
                var nodeNames = this.atts.node.split(",");
                var count = Math.min(nodeNames.length, data.length);
                for (var i = 0; i < count; i++) {
                    data[i] = this.getNodeByLevels(nodeNames[i], data[i]);
                }
            }
        }

        // Color schemes, which can be invoked by the parameter
        // colorscheme=N, where N is an index. Default is N=0.
        this.colors = [d3.schemeCategory20, ["#34B3E4", "#B79EC7", "#F38A78", "#EC9F48", "#57BFC1", "#F0C23B", "#F289B7", "#92C749", "#9D9FA1", "#046293", "#66418C", "#AF1923", "#A8480C", "#14717B", "#9E7C21", "#AC2258", "#4C792D", "#4D4F51"]];

        // If this is a comparison chart, then data is an array.
        if (data.constructor !== Array) {
            if (typeof this.atts.colorscheme === 'undefined' || typeof this.colors[this.atts.colorscheme] === 'undefined') {
                this.atts.colorscheme = 0;
            }
            this.setColors(data);
        }

        // The configuration, from the config.json file.
        this.avg_tax_bill = config['avg_tax_bill'];
        this.default_tax_year = config['default_tax_year'];
        this.fiscal_year_start = config['fiscal_year_start'];

        // The jQuery object for the chart div
        // and the chart's data.
        this.$div = $div;
        this.data = data;

        // Set the chart width & height if user set them.
        if (typeof this.atts.width !== 'undefined') {
            this.$div.width(this.atts.width);
        }
        if (typeof this.atts.height !== 'undefined') {
            this.$div.height(this.atts.height);
        }

        // Set the class if the user set such a parameter.
        if (typeof this.atts.class !== 'undefined') {
            this.$div.addClass(this.atts.class);
        }

        // Determine the initial date.
        // The shared state among charts. These properties are used
        // for the interaction between charts.
        this.state = {
            hash: this.data.hash,
            myTaxBill: this.determineMyTaxBill(this.avg_tax_bill),
            groups: [],
            date: this.getAttribute('date', this.getDefaultDate()).toString(),
            dragging: false,
            mouseX: null
        };

        console.log(this.state);

        // Bind the window resize event to the redraw function.
        window.addEventListener("resize", function () {
            _this.resize();
        });
    }

    _createClass(VbChart, [{
        key: 'redraw',
        value: function redraw() {
            // Redraw the chart.
            console.log('Drawing chart ' + this.atts.hash + '.');
            this.$div.html('[vb-chart]');
        }

        // Triggered by window resize.

    }, {
        key: 'resize',
        value: function resize() {
            this.redraw();
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            // Remove everything in the chart.
            console.log('Destroying chart ' + this.atts.hash + '.');
            // To do.
        }
    }, {
        key: 'setState',
        value: function setState(newState) {
            this.state = Object.assign({}, this.state, newState);
            this.redraw();
        }
    }, {
        key: 'setColors',
        value: function setColors(data) {
            // We will count through, getting new colors.
            var colorscheme = this.colors[this.atts.colorscheme];
            var i = 0;
            var pickAColor = function pickAColor() {
                if (!colorscheme[i]) {
                    i = 0;
                }
                return colorscheme[i++];
            };

            // Recurse through the hierarchy.
            var setColorsRecurse = function setColorsRecurse(array) {
                if (array.children.length > 0) {
                    for (var j = 0; j < array.children.length; j++) {
                        array.children[j].color = pickAColor();
                    }
                    for (var _j = 0; _j < array.children.length; _j++) {
                        setColorsRecurse(array.children[_j]);
                    }
                }
            };

            data.color = pickAColor();
            setColorsRecurse(data);
        }

        // The data-* properties are specified in the HTML with the additional
        // prefix of vb, so they are data-vb-*. Let's remove that unnecessary vb.

    }, {
        key: 'removeVbPrefixesOnAttributes',
        value: function removeVbPrefixesOnAttributes(atts) {

            function firstCharToLower(string) {
                return string.charAt(0).toLowerCase() + string.slice(1);
            }
            function removeVbPrefix(str) {
                return str.replace(/^vb/, '');
            }

            // We will clone the atts here with new keys.
            var newAtts = {};

            // Loop through each property and remove the vb- prefix from them.
            for (var key in atts) {
                if (atts.hasOwnProperty(key)) {
                    // Create a new key by removing the prefix of the old key
                    var newKey = removeVbPrefix(key);
                    newKey = firstCharToLower(newKey);

                    newAtts[newKey] = atts[key];
                }
            }

            return newAtts;
        }

        // Determines the "mytaxbill" value. Can come from (in order of priority) either
        // local persistent storage, the VB state, a chart attribute, or hardcoded default.

    }, {
        key: 'determineMyTaxBill',
        value: function determineMyTaxBill(defaultBill) {

            // Check to see if a value for mytaxbill is already locally stored for this session.
            var myTaxBill = this.getLocalStorageVar("myTaxBill");
            if (myTaxBill !== null) {
                return myTaxBill;
            }

            // If not, return the current state's myTaxBill.
            if (typeof this.state !== 'undefined') {
                return this.state.myTaxBill;
            }

            // If still not, return the attribute "mytaxbill".
            return this.getAttribute('mytaxbill', defaultBill);
        }

        // Returns the value of a locally stored variable, if it exists.
        // If storage is unavailable or the variable isn't stored, returns null.

    }, {
        key: 'getLocalStorageVar',
        value: function getLocalStorageVar(name) {
            var defaultVal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            if (typeof Storage !== "undefined") {
                if (sessionStorage[name]) {
                    return sessionStorage[name];
                }
            }
            return defaultVal;
        }

        // What is the dollarAmount corresponding to a given date for
        // a given node in the dataset?

    }, {
        key: 'dollarAmountOfDate',
        value: function dollarAmountOfDate(date) {
            var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.data;

            // Find the right dollar amount for our date.
            var dollarAmountObjs = [].concat(_toConsumableArray(node.dollarAmounts));
            var obj = this.filterTakeFirst(dollarAmountObjs, function (e) {
                return e.date == date;
            });
            return obj.dollarAmount;
        }

        // Returns the dollarAmount of the date multiplied by the tax ratio
        // (i.e. the meta property "FUNDED_BY_TAXES") for the item.
        // This function is recursive, calculating dollarAmount*taxRatio for each
        // leaf before summing them.

    }, {
        key: 'taxAdjustedDollarAmountOfDate',
        value: function taxAdjustedDollarAmountOfDate(date) {
            var _this2 = this;

            var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.data;

            if (node.children.length == 0) {
                // Find the right dollar amount for our date.
                var dollarAmountObjs = [].concat(_toConsumableArray(node.dollarAmounts));
                var obj = this.filterTakeFirst(dollarAmountObjs, function (e) {
                    return e.date == date;
                });

                // Get the "FUNDED_BY_TAXES" fraction. Constrain it to [0,1].
                var fundedByTaxes = this.getMetaProperty("FUNDED_BY_TAXES", 1, node);
                fundedByTaxes = Math.min(Math.max(fundedByTaxes, 0), 1);

                // Simply multiply
                return obj.dollarAmount * fundedByTaxes;
            } else {
                // There are children. Recurse over them.
                var childDollarAmounts = node.children.map(function (e) {
                    return _this2.taxAdjustedDollarAmountOfDate(date, e);
                });
                return childDollarAmounts.reduce(function (a, b) {
                    return a + b;
                }, 0);
            }
        }

        // Get a meta property (of the dataset) by name.

    }, {
        key: 'getMetaProperty',
        value: function getMetaProperty(propName) {
            var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
            var node = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.data;

            var meta = this.filterTakeFirst(node.meta, function (e) {
                return e.name == propName;
            });
            return meta ? meta.value : defaultValue;
        }

        // Get an attribute (i.e. query parameter) by name,
        // accounting for default value and acceptable values.
        //      name             : string
        //      defaultvalue     : string
        //      acceptableValues : array of strings

    }, {
        key: 'getAttribute',
        value: function getAttribute(name) {
            var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
            var acceptableValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

            // If the attribute isn't set, return the default.
            if (!this.atts.hasOwnProperty(name)) {
                return defaultValue;
            }

            // If the attribute is set and it isn't an acceptable value,
            // return the default as well.
            var value = this.atts[name];
            if (acceptableValues.length > 0 && acceptableValues.indexOf(value) == -1) {
                return defaultValue;
            } else {
                // Otherwise, return the set value.
                return value;
            }
        }
    }, {
        key: 'dollarAmountOfCurrentDate',
        value: function dollarAmountOfCurrentDate() {
            var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.data;

            return this.dollarAmountOfDate(this.state.date, node);
        }

        // Apply a filter function to an array and return the first match.
        // Return null if nothing in the array passes the filter.

    }, {
        key: 'filterTakeFirst',
        value: function filterTakeFirst(array, filterFunc) {
            var filtered = array.filter(filterFunc);

            if (filtered.length == 0) {
                // There were no elements matching the filter function.
                return null;
            } else {
                // Choose the first one, like the function name says.
                return filtered[0];
            }
        }
    }, {
        key: 'getDateRange',
        value: function getDateRange() {
            var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.data;

            // Get a list of all dates.
            var dates = [];
            data.dollarAmounts.forEach(function (obj) {
                dates.push(Date.parse(obj.date));
            });

            // Find the min and max.
            var minDate = dates.reduce(function (a, b) {
                return Math.min(a, b);
            });
            var maxDate = dates.reduce(function (a, b) {
                return Math.max(a, b);
            });

            return [new Date(minDate), new Date(maxDate)];
        }

        // Number formatter, based on code from
        // http://stackoverflow.com/a/9462382/1516307

    }, {
        key: 'nFormat',
        value: function nFormat(num) {
            var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

            var si = [{ value: 1E12, symbol: "T" }, { value: 1E9, symbol: "B" }, { value: 1E6, symbol: "M" }, { value: 1E3, symbol: "k" }],
                rx = /\.0+$|(\.[0-9]*[1-9])0+$/,
                i;
            for (i = 0; i < si.length; i++) {
                if (num >= si[i].value) {
                    return (num / si[i].value).toFixed(digits).replace(rx, "$1") + si[i].symbol;
                }
            }
            return num.toFixed(digits).replace(rx, "$1");
        }

        // Format amount, exactly

    }, {
        key: 'nFormatExact',
        value: function nFormatExact(value) {
            var commasFormatter = d3.format(",.0f");
            return commasFormatter(value);
        }

        // Format a percentage (with sign)

    }, {
        key: 'formatPercentage',
        value: function formatPercentage(value) {
            var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

            value = value.toFixed(digits);
            if (value > 0) {
                return "+ " + value.toString() + "%";
            } else if (value < 0) {
                return "â€“ " + Math.abs(value).toString() + "%";
            } else {
                return Math.abs(value).toString() + "%";
            }
        }

        // Get the index of a certain date in the dollarAmounts array.

    }, {
        key: 'getDateIndex',
        value: function getDateIndex(date) {
            var index = null;
            for (var i = 0; i < this.data.dollarAmounts.length; i++) {
                if (this.data.dollarAmounts[i].date == date) {
                    index = i;
                }
            }
            return index;
        }

        // What is the earliest date in the dataset?

    }, {
        key: 'getFirstDate',
        value: function getFirstDate() {
            var range = this.getDateRange();
            return range[0].getUTCFullYear();
        }

        // To title case

    }, {
        key: 'toTitleCase',
        value: function toTitleCase(str) {
            return str.replace(/(?:^|\s)\w/g, function (match) {
                return match.toUpperCase();
            });
        }

        // Return a node based on its hash.
        // FIXME: this function is used only by the treemap
        // and is specific to the d3.hierarchy object type.

    }, {
        key: 'findHash',
        value: function findHash(hash, root) {
            var node = null;
            root.each(function (d) {
                if (d.data.hash == hash) {
                    node = d;
                }
            });
            return node;
        }

        // FIXME: this function is basically same as above,
        // only it works on the VB chart data object type.

    }, {
        key: 'getNodeByHash',
        value: function getNodeByHash(hash, data) {

            if (!data) {
                data = this.data;
            }

            if (data.hash == hash) {
                return data;
            }

            var node = null;
            for (var i = 0; i < data.children.length; i++) {
                node = this.getNodeByHash(hash, data.children[i]);
                if (node) {
                    break;
                }
            }

            return node;
        }

        // Get a child node by its name.
        // Note: only searches in IMMEDIATE children of the data argument.

    }, {
        key: 'getChildNodeByName',
        value: function getChildNodeByName(str, data) {

            // Normalize our strings.
            var normalize = function normalize(s) {
                return s.replace(/ /g, "_").toLowerCase();
            };

            // Loop through, return the first match.
            for (var i = 0; i < data.children.length; i++) {
                var child = data.children[i];
                if (normalize(child.name) == normalize(str)) {
                    return child;
                }
            }

            return null;
        }

        // Get a node by a name ID.
        // e.g. Schools:Admin:Salaries
        // If not found, return the original data object.

    }, {
        key: 'getNodeByLevels',
        value: function getNodeByLevels(str, data) {
            var parts = str.split(":");
            var node = data;

            // Dive down into each part. At any point, if the right
            // child isn't found, return null.
            for (var i = 0; i < parts.length; i++) {
                node = this.getChildNodeByName(parts[i], node);
                if (!node) {
                    return data;
                }
            }

            return node;
        }

        // According to configuration settings.

    }, {
        key: 'getDefaultDate',
        value: function getDefaultDate() {
            // Current calendar year.
            var theYear = new Date().getFullYear();

            // When the fiscal year turns over.
            var endOfFiscalYear = new Date(this.fiscal_year_start + ' 1 ' + new Date().getFullYear());
            // Today's date.
            var today = new Date();

            // If we've passed the end of the fiscal year, increment.
            if (today > endOfFiscalYear) {
                theYear++;
            }

            // If the default tax year is "next year", increment again.
            if (this.default_tax_year == "next") {
                theYear++;
            }

            return theYear;
        }
    }]);

    return VbChart;
}();
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var VbComparisonTime = function (_VbChart) {
    _inherits(VbComparisonTime, _VbChart);

    function VbComparisonTime($div, data, config) {
        _classCallCheck(this, VbComparisonTime);

        // Make sure the data is an array. If only one dataset was
        // passed, we can still make a chart -- but we need it to
        // be an array with one object in it.
        if (data.constructor !== Array) {
            data = [data];
        }

        // Cast the data.
        data.forEach(function (dataset) {
            dataset.dollarAmounts.forEach(function (d) {
                d.dollarAmount = +d.dollarAmount;
            });
        });

        // Call super method.

        // Set up the SVG.
        var _this = _possibleConstructorReturn(this, (VbComparisonTime.__proto__ || Object.getPrototypeOf(VbComparisonTime)).call(this, $div, data, config));

        _this.setupChartSvg();
        return _this;
    }

    _createClass(VbComparisonTime, [{
        key: 'redraw',
        value: function redraw() {
            console.log('Drawing chart ' + this.atts.hash + ' (time comparison).');
            d3.selectAll('#' + this.$div.attr('id') + ' svg g *').remove();
            this.adjustSize();
            this.drawChart();
        }
    }, {
        key: 'setState',
        value: function setState(newState) {
            this.state = Object.assign({}, this.state, newState);

            // Redraw
        }
    }, {
        key: 'setupChartSvg',
        value: function setupChartSvg() {
            // Set the chart width and height and margin variables.
            this.setChartVars();

            var $div = this.$div;
            var chart = this.chart;

            // Adds the svg canvas
            this.svg = d3.select($div.get(0)).append("svg").attr("class", "svg-chart").attr("width", chart.width).attr("height", chart.height).append("g").attr("transform", "translate(" + chart.margin.left + "," + chart.margin.top + ")");
        }
    }, {
        key: 'setChartVars',
        value: function setChartVars() {
            this.chart = {};
            var margin = this.chart.margin = { top: 30, right: 20, bottom: 30, left: 50 };
            var width = this.chart.width = this.$div.width();
            var height = this.chart.height = this.$div.height();
            this.chart.xwidth = width - margin.right - margin.left;
            this.chart.yheight = height - margin.top - margin.bottom;
        }
    }, {
        key: 'adjustSize',
        value: function adjustSize() {
            this.setChartVars();
            var chart = this.chart;

            d3.select(this.$div.get(0)).select('svg').attr('width', chart.width).attr('height', chart.height);
        }

        /* Draw the actual chart.
         * This code is modified from
         * https://bl.ocks.org/mbostock/3887051
         */

    }, {
        key: 'drawChart',
        value: function drawChart() {
            var that = this;
            var data = this.data;
            var chart = this.chart;
            var svg = this.svg;

            // Set up the dimensions
            var x0 = d3.scaleBand().rangeRound([0, chart.xwidth]).paddingInner(0.1);

            var x1 = d3.scaleBand().padding(0.05);

            var y = d3.scaleLinear().rangeRound([chart.yheight, 0]);

            var z = d3.scaleOrdinal().range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);

            // Find the years common between all datasets.
            var dates = data[0].dollarAmounts.map(function (d) {
                return d.date;
            });
            data.slice(1).forEach(function (dataset) {
                var nextDates = dataset.dollarAmounts.map(function (d) {
                    return d.date;
                });
                dates = dates.filter(function (d) {
                    return nextDates.indexOf(d) >= 0 ? 1 : 0;
                });
            });

            // Create a flat data array of all the datapoints we wish to plot.
            // Right now the datapoints are distributed between multiple
            // hierarchial JSON objects.
            var datapoints = [];
            var datasetNames = [];
            data.forEach(function (dataset) {
                datasetNames.push(dataset.name);
                dataset.dollarAmounts.forEach(function (d) {
                    // Check that we actually want to plot this year.
                    if (dates.indexOf(d.date)) {
                        datapoints.push({
                            datasetName: dataset.name,
                            dollarAmount: d.dollarAmount,
                            date: d.date
                        });
                    }
                });
            });

            // These are the data formatted as required by the D3 code below.
            var nestedDatapoints = d3.nest().key(function (d) {
                return d.date;
            }).entries(datapoints);

            // The domains
            x0.domain(datapoints.map(function (d) {
                return d.date;
            }));
            x1.domain(datasetNames).rangeRound([0, x0.bandwidth()]);
            y.domain([0, d3.max(datapoints, function (d) {
                return d.dollarAmount;
            })]).nice();

            // Add the bars of the chart
            svg.append("g").selectAll("g").data(nestedDatapoints).enter().append("g").attr("transform", function (d) {
                return "translate(" + x0(d.key) + ",0)";
            }).selectAll("rect").data(function (d) {
                return d.values;
            }).enter().append("rect").attr("x", function (d) {
                return x1(d.datasetName);
            }).attr("y", function (d) {
                return y(d.dollarAmount);
            }).attr("width", x1.bandwidth()).attr("height", function (d) {
                return chart.yheight - y(d.dollarAmount);
            }).attr("fill", function (d) {
                return z(d.datasetName);
            });

            // X axis
            var ticks_count = chart.xwidth < 400 ? 2 : null;
            svg.append("g").attr("class", "axis").attr("transform", "translate(0," + chart.yheight + ")").call(d3.axisBottom(x0).ticks(ticks_count));
            // FIXME: Why doesn't this ticks_count work?

            // Y axis
            svg.append("g").attr("class", "axis").call(d3.axisLeft(y).ticks(null, "s"));

            /*
                    var legend = g.append("g")
                        .attr("font-family", "sans-serif")
                        .attr("font-size", 10)
                        .attr("text-anchor", "end")
                      .selectAll("g")
                      .data(keys.slice().reverse())
                      .enter().append("g")
                        .attr("transform", (d,i) => "translate(0," + i * 20 + ")" );
            
                    legend.append("rect")
                        .attr("x", width - 19)
                        .attr("width", 19)
                        .attr("height", 19)
                        .attr("fill", z);
            
                    legend.append("text")
                        .attr("x", width - 24)
                        .attr("y", 9.5)
                        .attr("dy", "0.32em")
                        .text(d => d);
            */
        }
    }]);

    return VbComparisonTime;
}(VbChart);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var VbLegend = function (_VbChart) {
    _inherits(VbLegend, _VbChart);

    function VbLegend($div, data, config) {
        _classCallCheck(this, VbLegend);

        // If multiple datasets were passed in, abort.
        if (data.constructor === Array) {
            return _possibleConstructorReturn(_this);
        }

        // Cast the data.
        data.dollarAmounts.forEach(function (d) {
            // d.date = Date.parse(d.date);
            d.dollarAmount = +d.dollarAmount;
        });

        // Call super method.
        return _possibleConstructorReturn(this, (VbLegend.__proto__ || Object.getPrototypeOf(VbLegend)).call(this, $div, data, config));
    }

    _createClass(VbLegend, [{
        key: 'redraw',
        value: function redraw() {
            console.log('Drawing chart ' + this.atts.hash + ' (legend).');
            this.drawLegend();
        }
    }, {
        key: 'setState',
        value: function setState(newState) {
            this.state = Object.assign({}, this.state, newState);

            // Redraw
            this.redraw();
        }

        /* Draw the actual chart.
         */

    }, {
        key: 'drawLegend',
        value: function drawLegend() {
            var node = this.getNodeByHash(this.state.hash) || this.data;

            var li = function li(text, color) {
                var style = 'background-image: url("data:image/svg+xml,' + '<svg xmlns=\\"http://www.w3.org/2000/svg\\" ' + 'viewBox=\\"0 0 10 10\\"><circle fill=\\"' + color + '\\" cx=\\"5\\" cy=\\"5\\" r=\\"5\\"/></svg>");';

                return '<li style=\'' + style + '\'">' + text + '</li>';
            };

            var items = [];
            for (var i = 0; i < node.children.length; i++) {
                items.push(li(node.children[i].name, node.children[i].color));
            }

            var html = "<ul>" + items.join("") + "</ul>";
            this.$div.html(html);
        }
    }]);

    return VbLegend;
}(VbChart);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var VbLineChart = function (_VbChart) {
    _inherits(VbLineChart, _VbChart);

    function VbLineChart($div, data, config) {
        _classCallCheck(this, VbLineChart);

        // Cast the data.
        data.dollarAmounts.forEach(function (d) {
            // d.date = Date.parse(d.date);
            d.dollarAmount = +d.dollarAmount;
        });

        // Call super method.

        // Set up the SVG.
        var _this = _possibleConstructorReturn(this, (VbLineChart.__proto__ || Object.getPrototypeOf(VbLineChart)).call(this, $div, data, config));

        _this.setupChartSvg();

        // Bind events.
        _this.addActions();
        return _this;
    }

    _createClass(VbLineChart, [{
        key: 'redraw',
        value: function redraw() {
            console.log('Drawing chart ' + this.atts.hash + ' (linechart).');
            d3.selectAll('#' + this.$div.attr('id') + ' svg g *').remove();
            this.adjustSize();

            var data = this.getNodeByHash(this.state.hash);
            this.drawChart(data);
        }
    }, {
        key: 'setState',
        value: function setState(newState) {
            var oldHash = this.state.hash;
            var newHash = newState.hash;
            this.state = Object.assign({}, this.state, newState);

            // Do not redraw everything here.
            this.moveHoverline();

            // ...unless the hash is changed.
            if (oldHash != newHash) {
                this.redraw();
            }
        }
    }, {
        key: 'setupChartSvg',
        value: function setupChartSvg() {
            // Set the chart width and height and margin variables.
            this.setChartVars();

            var $div = this.$div;
            var chart = this.chart;

            // Adds the svg canvas
            this.svg = d3.select($div.get(0)).append("svg").attr("class", "svg-chart").attr("width", chart.width).attr("height", chart.height).append("g").attr("transform", "translate(" + chart.margin.left + "," + chart.margin.top + ")");
        }
    }, {
        key: 'setChartVars',
        value: function setChartVars() {
            this.chart = {};
            var margin = this.chart.margin = { top: 30, right: 20, bottom: 30, left: 50 };
            var width = this.chart.width = this.$div.width();
            var height = this.chart.height = this.$div.height();
            this.chart.xwidth = width - margin.right - margin.left;
            this.chart.yheight = height - margin.top - margin.bottom;
        }
    }, {
        key: 'adjustSize',
        value: function adjustSize() {
            this.setChartVars();
            var chart = this.chart;

            d3.select(this.$div.get(0)).select('svg').attr('width', chart.width).attr('height', chart.height);
        }

        // FIXME: This function should be broken up into drawAxes(), drawLine(data), etc.

    }, {
        key: 'drawChart',
        value: function drawChart(data) {
            var that = this;
            var chart = this.chart;
            var svg = this.svg;

            var inDateRange = function inDateRange(range) {
                return function (d) {
                    return true; // return d.date >= range[0] && d.date <= range[1];
                };
            };

            // Parse the date / time
            var parseDate = d3.timeFormat("%d-%b-%y").parse;

            // Set the ranges
            var x = d3.scaleTime().range([0, chart.xwidth]);
            var y = d3.scaleLinear().range([chart.yheight, 0]);

            // Define the axes
            // only show the year in the x-axis, not the month
            var ticks_count = chart.xwidth < 390 ? 2 : null;
            var xAxis = d3.axisBottom().scale(x).ticks(ticks_count);
            var yAxis = d3.axisLeft().scale(y).tickFormat(function (val) {
                return '$' + that.nFormat(val, 0);
            });

            // Define the line
            var valueline = d3.line().x(function (d) {
                return x(new Date(d.date));
            }).y(function (d) {
                return y(d.dollarAmount);
            });
            // .curve(d3.curveCardinal.tension(0.5));

            // Scale the range of the data
            // x.domain(d3.extent(data.dollarAmounts.filter(inDateRange(null)),
            //     function(d) { return d.date; }));
            x.domain(this.getDateRange());
            y.domain([0, d3.max(data.dollarAmounts.filter(inDateRange(null)), function (d) {
                return d.dollarAmount;
            })]);

            // Add the valueline path.
            svg.append("path").attr("class", "line").attr("d", valueline(data.dollarAmounts.filter(inDateRange(null))));

            // Plot points on the line.
            svg.selectAll("g.circles-line").data([data.dollarAmounts]).enter().append("g").attr("class", "circles-line").selectAll("circle").data(function (d) {
                return d;
            }).enter().append("circle").attr("r", 4).attr("cx", function (d, i) {
                return x(new Date(d.date));
            }).attr("cy", function (d, i) {
                return y(d.dollarAmount);
            });

            // Add the X Axis
            svg.append("g").attr("class", "x axis").attr("transform", "translate(0," + chart.yheight + ")").call(xAxis);

            // Add the Y Axis
            svg.append("g").attr("class", "y axis").call(yAxis);

            // For global use
            chart.x = x;
            chart.y = y;

            // This is an invisible div that ensures every click on the chart is captured.
            // Without it, clicks above the line may not trigger the click event.
            svg.append('rect').attr('class', 'click-capture').style('visibility', 'hidden').attr('width', chart.width).attr('height', chart.height);

            // Hoverline
            var xpos = this.chart.x(new Date(this.state.date));
            this.hoverline = svg.append("line").attr("x1", xpos).attr("x2", xpos).attr("y1", 0).attr("y2", chart.yheight).attr("class", "hoverline");
        }
    }, {
        key: 'moveHoverline',
        value: function moveHoverline() {
            // Note that the year must be a string here;
            // otherwise it is interpreted as unix time.
            var xpos = this.chart.x(new Date(this.state.date));
            this.hoverline.attr("x1", xpos).attr("x2", xpos);
        }

        // Add interaction actions.

    }, {
        key: 'addActions',
        value: function addActions() {
            var that = this;

            function getMouseX(e) {
                var x = void 0;
                // Makes event valid for both touch and mouse devices
                if (e.type === 'touchstart') {
                    x = e.touches[0].pageX;
                } else {
                    // Solves some IE compatibility issues
                    x = e.offsetX || d3.mouse(this)[0];
                }
                return x - that.chart.margin.left;
            }
            function getMouseY(e) {
                // Makes event valid for both touch and mouse devices
                if (e.type === 'touchstart') {
                    return e.touches[0].pageY;
                } else {
                    // Solves some IE compatibility issues
                    return e.offsetY || d3.mouse(this)[1];
                }
            }

            function mousedown_callback(e) {
                e = d3.event;
                e.preventDefault();
                var mouseX = getMouseX(e);
                var dateobj = that.chart.x.invert(mouseX); //.getUTCFullYear()
                var date = dateobj.getMonth() <= 6 ? dateobj.getUTCFullYear() : dateobj.getUTCFullYear() + 1;
                visualbudget.broadcastStateChange({
                    date: "" + date, // cast to string
                    dragging: true
                });
            }
            function mousemove_callback(e) {
                if (that.state.dragging) {
                    mousedown_callback(e);
                }
            }
            function mouseup_callback(e) {
                e = d3.event;
                e.preventDefault();
                visualbudget.broadcastStateChange({
                    dragging: false
                });
            }
            function mouseout_callback(e) {
                e = d3.event;
                e.preventDefault();
                visualbudget.broadcastStateChange({
                    dragging: false
                });
            }

            this.svg.on('mousedown', mousedown_callback);
            this.svg.on('mousemove', mousemove_callback);
            this.svg.on('mouseup', mouseup_callback);
        }
    }]);

    return VbLineChart;
}(VbChart);
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
 * Metrics: calculated sums, differences, and averages displayed
 * as text in a <span> element.
 */
var VbMetric = function (_VbChart) {
    _inherits(VbMetric, _VbChart);

    function VbMetric($div, data, config) {
        _classCallCheck(this, VbMetric);

        var _this = _possibleConstructorReturn(this, (VbMetric.__proto__ || Object.getPrototypeOf(VbMetric)).call(this, $div, data, config));

        // Cast the data.
        // data.dollarAmounts.forEach(function(d) {
        //     // d.date = Date.parse(d.date);
        //     d.dollarAmount = +d.dollarAmount;
        // });

        // Call super method.


        $div.css({ "display": "inline" });
        return _this;
    }

    _createClass(VbMetric, [{
        key: "redraw",
        value: function redraw() {
            console.log('Drawing chart ' + this.atts.hash + ' (metric).');

            var data = this.getNodeByHash(this.state.hash);
            var metric = this.getMetric(this.atts.metric, this.state, data);

            this.$div.html(metric);
        }
    }, {
        key: "getMetric",
        value: function getMetric(name, state, data) {
            var metric = null;

            switch (name) {
                case 'date':
                    metric = state.date;
                    break;

                case 'datetotal':
                    metric = this.getMetricDateTotal(state, data);
                    break;

                case 'average':
                    metric = this.getMetricAverage(state, data);
                    break;

                case '5yearaverage':
                    metric = this.getMetric5YearAverage(state, data);
                    break;

                case 'numyearsaveraged':
                    metric = this.getMetricNumYearsAveraged(state);
                    break;

                case 'percentgrowth':
                    metric = this.getMetricPercentGrowth(state, data);
                    break;

                case 'absgrowth':
                    metric = this.getMetricAbsGrowth(state, data);
                    break;

                case 'name':
                    metric = this.getMetricName(state, data);
                    break;

                case 'download':
                    metric = this.getMetricDownloadLink();
                    break;

                case 'mytaxcontribution':
                    metric = this.getMetricMyTaxContribution(state, data);
                    break;

                default:
                    metric = '?'; // Don't be too disruptive to the viewer.
            }

            return metric;
        }

        /* The total for a certain date.
         */

    }, {
        key: "getMetricDateTotal",
        value: function getMetricDateTotal(state, data) {
            var metric = this.dollarAmountOfDate(state.date, data);
            if (metric === null) {
                return 'N/A';
            }
            metric = '$' + this.nFormat(metric, 1);
            return metric;
        }

        /* The average over all dates.
         */

    }, {
        key: "getMetricAverage",
        value: function getMetricAverage(state, data) {
            var metric = data.dollarAmounts.reduce(function (a, b) {
                return a + b.dollarAmount;
            }, 0) / data.dollarAmounts.length;
            metric = '$' + this.nFormat(metric, 1);
            return metric;
        }

        /* The average of the last 5 years (or less than five years for
         * the right boundary condition).
         */

    }, {
        key: "getMetric5YearAverage",
        value: function getMetric5YearAverage(state, data) {
            var firstDate = this.getFirstDate();
            var date = state.date;
            var diff = Math.min(5, date - firstDate + 1);
            var metric = 0;
            for (var i = 0; i < diff; i++) {
                metric = metric + this.dollarAmountOfDate(date - i, data);
            }
            return '$' + this.nFormat(metric / diff);
        }

        /* Since the 5-year average is not actually always over five years
         * (because of the boundary condition), this metric gives the actual
         * number of years that have been averaged.
         */

    }, {
        key: "getMetricNumYearsAveraged",
        value: function getMetricNumYearsAveraged(state) {
            var firstDate = this.getFirstDate();
            var date = state.date;
            var diff = Math.min(5, date - firstDate + 1);
            return diff;
        }

        /* The percent growth from the previous year (can be negative).
         */

    }, {
        key: "getMetricPercentGrowth",
        value: function getMetricPercentGrowth(state, data) {
            var date = state.date;
            var metric = "N/A";
            var sign = "+"; // The default minus sign is really a hyphen.

            // Check to see if the previous year existed.
            // If not, metric will be "N/A";
            if (this.getFirstDate() <= date - 1) {
                var cur = this.dollarAmountOfDate(date, data);
                var prev = this.dollarAmountOfDate(date - 1, data);
                var pct = (cur - prev) / prev * 100;
                if (pct < 0) {
                    sign = '&minus;';
                }
                metric = sign + Math.abs(pct).toFixed(2) + "%";
            }
            return metric;
        }

        /* The absolute (dollar-amount) growth from the previous year (can be negative).
         */

    }, {
        key: "getMetricAbsGrowth",
        value: function getMetricAbsGrowth(state, data) {
            var date = state.date;
            var metric = "N/A";
            var sign = "+"; // The default minus sign is really a hyphen.

            // Check to see if the previous year existed.
            // If not, metric will be "N/A";
            if (this.getFirstDate() <= date - 1) {
                var diff = this.dollarAmountOfDate(date, data) - this.dollarAmountOfDate(date - 1, data);
                if (diff < 0) {
                    sign = '&minus;';
                }
                metric = sign + '$' + this.nFormat(Math.abs(diff), 1);
            }
            return metric;
        }

        /* Get the name of the node
         */

    }, {
        key: "getMetricName",
        value: function getMetricName(state, data) {
            if (this.isNumeric(data.name)) {
                // There is no chart parameter for name, and only
                // a dataset ID is given. Return an empty string
                // rather than a number.
                return '';
            } else {
                // There is a name defined. In the chart's constructor
                // this was set to either a defined query/shortcode attribute
                // or the dataset alias in title case.
                return data.name;
            }
        }

        /* Get the download link. Multiple links if multiple datasets.
         */

    }, {
        key: "getMetricDownloadLink",
        value: function getMetricDownloadLink() {
            // Set defaults for attributes.
            if (!("text" in this.atts)) {
                this.atts.text = "Download data";
            }
            if (!("title" in this.atts)) {
                this.atts.title = "Download data";
            }
            if (!("target" in this.atts)) {
                this.atts.target = "_blank";
            }

            // A simple function for replacing the .json extension with
            // an arbitrary extension, so the correct link is displayed.
            var setFiletype = function setFiletype(filename, ext) {
                return filename.substr(0, filename.lastIndexOf(".")) + "." + ext;
            };

            // The default file extension is CSV. If the query param
            // filetype=json is set, then JSON is instead linked.
            var filetype = 'csv';
            if (this.atts.filetype == 'json') {
                filetype = 'json';
            }

            // Initialize the html variable.
            var html = '';

            // Generate the links. Logic here forks depending on
            // how many URLs there are.
            if ("datasetUrls" in this.atts) {
                // In this case, there are multiple datasets.
                var urls = this.atts.datasetUrls.split(',');
                var linkStrings = [];
                html = this.atts.text;
                for (var i = 0; i < urls.length; i++) {

                    // The filetype will be CSV or JSON spending on query params.
                    var theUrl = setFiletype(urls[i], filetype);

                    linkStrings.push(jQuery('<a>', {
                        text: i + 1 + '', // convert to string
                        title: this.atts.title,
                        href: theUrl,
                        target: this.atts.target
                    }).prop('outerHTML'));
                }
                html += ' [' + linkStrings.join(', ') + ']';
            } else if ("datasetUrl" in this.atts) {
                // In this case, there is only one dataset.

                // The filetype will be CSV or JSON spending on query params.
                var _theUrl = setFiletype(this.atts.datasetUrl, filetype);

                html = jQuery('<a>', {
                    text: this.atts.text,
                    title: this.atts.title,
                    href: _theUrl,
                    target: this.atts.target
                }).prop('outerHTML');
            } else {
                // If no datasets were specified, only include an HTML comment.
                html = '<!-- No dataset URLs specified. -->';
            }

            return html;
        }

        /* Get the metric for "my tax contribution"
         */

    }, {
        key: "getMetricMyTaxContribution",
        value: function getMetricMyTaxContribution(state, data) {
            var metric = '';
            if (state.myTaxBill !== '') {
                var total = this.taxAdjustedDollarAmountOfDate(state.date);
                var subTotal = this.taxAdjustedDollarAmountOfDate(state.date, data);
                var myBill = state.myTaxBill;
                var myContribution = myBill * (subTotal / total);
                metric = "$" + myContribution.toFixed(2);
            }
            return metric;
        }

        /* Checks to see if input is numeric
         */

    }, {
        key: "isNumeric",
        value: function isNumeric(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }
    }]);

    return VbMetric;
}(VbChart);
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
 * My Tax Bill: This component allows the user to enter their tax bill
 * and to see where each penny of it goes (via treemap or linechart).
 */
var VbMyTaxBill = function (_VbChart) {
    _inherits(VbMyTaxBill, _VbChart);

    function VbMyTaxBill($div, config) {
        _classCallCheck(this, VbMyTaxBill);

        // Make it inline.
        var _this = _possibleConstructorReturn(this, (VbMyTaxBill.__proto__ || Object.getPrototypeOf(VbMyTaxBill)).call(this, $div, [], config));

        // Call super method.


        $div.css({ "display": "inline" });

        // Add the input.
        _this.constructInput();

        // Bind the event for input change.
        // The "propertychange" event is for IE <9.
        jQuery('.vb-mytaxbill').on('input propertychange', _this.inputChangeHandler(_this));
        return _this;
    }

    // The redraw just ensures the value of the input is set correctly.


    _createClass(VbMyTaxBill, [{
        key: "redraw",
        value: function redraw() {
            console.log('Drawing chart ' + this.atts.hash + ' (mytaxbill).');
            this.$div.find('.vb-mytaxbill').val(this.state.myTaxBill);
            console.log('My Tax Bill is ' + this.state.myTaxBill + ".");
        }

        // Triggered by window resize.

    }, {
        key: "resize",
        value: function resize() {
            this.redraw();
        }

        // Create the HTML element for the input.

    }, {
        key: "constructInput",
        value: function constructInput() {
            this.$div.append("<span>$</span><input type='text' class='vb-mytaxbill' placeholder='" + this.defaulttaxbill + "' value='" + this.getLocalStorageVar("myTaxBill", "") + "'>");
        }

        // The handler for the 'input' event.

    }, {
        key: "inputChangeHandler",
        value: function inputChangeHandler(that) {
            return function (event) {

                // First validate the input.
                var string = event.target.value;
                var validatedString = string.replace(/[^\d\.]/g, '').replace(/^\.*/, '').replace(/(\.\d{0,2})(.*)/, '$1');
                var validNumber = Math.abs(parseFloat(validatedString));
                if (!validNumber && validNumber !== 0) {
                    validNumber = '';
                }

                // Store the tax bill in local storage if it's supported.
                if (typeof Storage !== "undefined") {
                    sessionStorage.myTaxBill = validNumber;
                } else {
                    console.log("Local storage not supported. 'My Tax Bill' will not be " + "persistent across this session.");
                }

                // Broadcast the change to set the state.
                // (The value of the input will change when the broadcast,
                // which bubbles back down to here, is received.)
                visualbudget.broadcastStateChange({
                    myTaxBill: validNumber
                });
            };
        }
    }]);

    return VbMyTaxBill;
}(VbChart);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var VbStackedArea = function (_VbChart) {
    _inherits(VbStackedArea, _VbChart);

    function VbStackedArea($div, data, config) {
        _classCallCheck(this, VbStackedArea);

        // Cast the data.
        data.dollarAmounts.forEach(function (d) {
            // d.date = Date.parse(d.date);
            d.dollarAmount = +d.dollarAmount;
        });

        // Call super method.

        // Smooth or stepwise graph?
        var _this = _possibleConstructorReturn(this, (VbStackedArea.__proto__ || Object.getPrototypeOf(VbStackedArea)).call(this, $div, data, config));

        _this.smooth = _this.getAttribute('smooth', false);

        // Set up the SVG.
        _this.setupChartSvg();

        // Bind events.
        _this.addActions();
        return _this;
    }

    _createClass(VbStackedArea, [{
        key: 'redraw',
        value: function redraw() {
            console.log('Drawing chart ' + this.atts.hash + ' (stackedarea).');
            d3.selectAll('#' + this.$div.attr('id') + ' svg g *').remove();
            this.adjustSize();

            var data = this.getNodeByHash(this.state.hash);
            this.drawChart(data);
        }
    }, {
        key: 'setState',
        value: function setState(newState) {
            var oldHash = this.state.hash;
            var newHash = newState.hash || oldHash;
            this.state = Object.assign({}, this.state, newState);

            // Do not redraw everything here.
            this.moveHoverline();

            // ...unless the hash is changed.
            if (oldHash != newHash) {
                this.redraw();
            }
        }
    }, {
        key: 'setupChartSvg',
        value: function setupChartSvg() {
            // Set the chart width and height and margin variables.
            this.setChartVars();

            var $div = this.$div;
            var chart = this.chart;

            // Adds the svg canvas
            this.svg = d3.select($div.get(0)).append("svg").attr("class", "svg-chart").attr("width", chart.width).attr("height", chart.height).append("g").attr("transform", "translate(" + chart.margin.left + "," + chart.margin.top + ")");
        }
    }, {
        key: 'setChartVars',
        value: function setChartVars() {
            this.chart = {};
            var margin = this.chart.margin = { top: 30, right: 20, bottom: 30, left: 50 };
            var width = this.chart.width = this.$div.width();
            var height = this.chart.height = this.$div.height();
            this.chart.xwidth = width - margin.right - margin.left;
            this.chart.yheight = height - margin.top - margin.bottom;
        }
    }, {
        key: 'adjustSize',
        value: function adjustSize() {
            this.setChartVars();

            d3.select(this.$div.get(0)).select('svg').attr('width', this.chart.width).attr('height', this.chart.height);
        }
    }, {
        key: 'drawChart',
        value: function drawChart(data) {
            var that = this;
            var chart = this.chart;
            var svg = this.svg;

            var inDateRange = function inDateRange(range) {
                return function (d) {
                    // Currently the chart shows all dates, always.
                    return true; // return d.date >= range[0] && d.date <= range[1];
                };
            };

            this.svg.layers = svg.append('g');

            // Parse the date / time
            var parseDate = d3.timeFormat("%d-%b-%y").parse;

            // Set the ranges
            var x = d3.scaleTime().range([0, chart.xwidth]);
            var y = d3.scaleLinear().range([chart.yheight, 0]);

            // Define the axes
            // only show the year in the x-axis, not the month
            var ticks_count = chart.xwidth < 390 ? 2 : null;
            var xAxis = d3.axisBottom().scale(x).ticks(ticks_count);
            var yAxis = d3.axisLeft().scale(y).tickFormat(function (val) {
                return '$' + that.nFormat(val, 0);
            });

            // Define the line
            var valueline = d3.line().x(function (d) {
                return x(new Date(d.date));
            }).y(function (d) {
                return y(d.dollarAmount);
            });
            // .curve(d3.curveCardinal.tension(0.5));

            // Scale the range of the data
            // x.domain(d3.extent(data.dollarAmounts.filter(inDateRange(null)),
            //     function(d) { return d.date; }));
            x.domain(this.getDateRange());
            y.domain([0, d3.max(data.dollarAmounts.filter(inDateRange(null)), function (d) {
                return d.dollarAmount;
            })]);

            // If the chart is smooth, plot the line and points.
            if (this.isSmooth()) {

                // Add the valueline path.
                svg.append("path").attr("class", "line").attr("d", valueline(data.dollarAmounts.filter(inDateRange(null))));

                // Plot points on the line.
                svg.selectAll("g.circles-line").data([data.dollarAmounts]).enter().append("g").attr("class", "circles-line").selectAll("circle").data(function (d) {
                    return d;
                }).enter().append("circle").attr("r", 3).attr("cx", function (d, i) {
                    return x(new Date(d.date));
                }).attr("cy", function (d, i) {
                    return y(d.dollarAmount);
                });
            }

            // Add the X Axis
            svg.append("g").attr("class", "x axis").attr("transform", "translate(0," + chart.yheight + ")").call(xAxis);

            // Add the Y Axis
            svg.append("g").attr("class", "y axis").call(yAxis);

            // For global use
            chart.x = x;
            chart.y = y;

            // This is an invisible div that ensures every click on the chart is captured.
            // Without it, clicks above the line may not trigger the click event.
            svg.append('rect').attr('class', 'click-capture').style('visibility', 'hidden').attr('width', chart.width).attr('height', chart.height);

            // Hoverline
            var xpos = this.chart.x(new Date(this.state.date));
            this.hoverline = svg.append("line").attr("x1", xpos).attr("x2", xpos).attr("y1", 0).attr("y2", chart.yheight).attr("class", "hoverline");

            // Now draw the layers (either areas or stacked bars).
            this.drawLayers(data);

            // Finally, set the hoverline.
            this.moveHoverline();
        }

        /*
        * Draws stacked area layers or stacked bars, depending on if
        * the chart is "smooth".
        *
        * @param {node} data - node for which data has to be displayed
        */

    }, {
        key: 'drawLayers',
        value: function drawLayers(data) {

            var svg = this.svg;
            var chart = this.chart;
            var $div = this.$div;

            /*
            // puts a shadow at boundary between layered
            // and non-layered part of the chart
            function appendShadow(group) {
                 if (ie() || jQuery.browser.mobile) return;
                 // clips the shadow so that it doesn't take the full height of the chart
                chart.sideShadow.attr("clip-path", "url(#areaclip)");
                 // the shadow is a foreignobject (div) to which
                // the css property 'box-shadow' is applied to.
                chart.layerLine = group.append("foreignObject")
                    .attr('x', chart.layersWidth - 10)
                        .attr('width', 10)
                        .attr('y', 10)
                        .attr('height', chart.yscale.range()[0] - 10)
                    .attr("class", "foreignobj")
                 chart.layerLine.append("xhtml:div").style('width', (3).px())
                    .style('height', (chart.yscale.range()[0] - 10).px())
                    .classed('layerLine', true);
            }
            */

            // Layers are a whole new svg image, this is done so that
            // the width of this svg can be easily adjusted to whatever desired
            // value, giving the illusion of 'clipping' the layers
            var layers = svg.layers.append('svg').attr("height", chart.yheight).attr("width", chart.xwidth).classed('layers', true);

            // Clip area used by boundary shadow
            layers.attr("clip-path", "url(#areaclip)");

            svg.layers.svg = layers;
            svg.layers.classed('layers', true);
            layers.width = chart.xwidth;
            layers.height = chart.yheight;

            // Half-transparent layer hides everything to the right
            // of the hoverline.
            var xpos = this.chart.x(new Date(this.state.date));
            svg.layers.veil = svg.layers.append('rect').attr("height", chart.yheight).attr("width", chart.xwidth).attr("x", xpos).attr("y", 0).attr("fill", 'white').attr("fill-opacity", .5);

            // if there is only one entry being displayed:
            // format it so the subsequent code can still draw a layer for it
            var singleAreaColor = false;

            // this is kind of a hack
            // because areas with 1 sub get draw 2 layers deep
            // to be fixed soon
            if (data.children.length == 0 || data.children.length == 1) {
                singleAreaColor = data.color;
            }

            // If there are no children, we've got to fudge it a bit
            // so the data's in the right format.
            if (data.children.length == 0) {
                var newChildren = jQuery.extend({}, data);
                data.children.push(newChildren);
                data.children[0].children = [];
                data.depth = 0;
            }

            var yscale = chart.y;
            var xscale = chart.x;

            layers.xscale = xscale;

            // We have to reorder the data for the stack.
            var newData = [];
            var keys = data.children.map(function (d) {
                return d.name;
            });
            var colors = data.children.map(function (d) {
                return d.color;
            });
            for (var i = 0; i < data.dollarAmounts.length; i++) {
                var date = data.dollarAmounts[i].date;
                var dataPoint = {};
                dataPoint.date = date;
                for (var j = 0; j < data.children.length; j++) {
                    var child = data.children[j];
                    dataPoint[child.name] = this.dollarAmountOfDate(date, child);
                }
                newData.push(dataPoint);
            }

            // Stack declaration
            var stack = d3.stack().keys(keys).order(d3.stackOrderAscending);
            var instance = stack(newData);

            // Calculate areas
            if (this.isSmooth()) {
                // It will be a line chart.

                // Line declaration.
                var area = d3.area()
                // .interpolate("monotone")
                .x(function (d) {
                    return xscale(new Date(d.data.date));
                }).y0(function (d) {
                    return yscale(d[0]);
                }).y1(function (d) {
                    return yscale(d[1]);
                });

                // Create the regions
                var regions = layers.selectAll(".browser").data(instance).enter().append("g").attr("class", "browser");

                // Draw the areas
                layers.areas = regions.append("path").attr("class", "multiarea").attr("d", area).style("fill", function (d, i) {
                    return colors[i];
                });
            } else {
                (function () {
                    // It will be a bar chart.

                    // This is a dummy array needed for the scaleband, just so it
                    // knows how many bands there are. The values doesn't matter for us.
                    var dummyArray = Array(data.dollarAmounts.length).fill().map(function (x, i) {
                        return i;
                    });

                    var newx = d3.scaleBand().rangeRound([0, chart.xwidth]).padding(0).domain(dummyArray); // number of bars on graph

                    var regions = layers.selectAll(".browser").data(instance).enter().append("g").attr('fill', function (d, i) {
                        return colors[i];
                    }).selectAll("rect").data(function (d) {
                        return d;
                    }).enter().append("rect").attr('class', 'multibar').attr("x", function (d) {
                        return xscale(new Date(d.data.date));
                    }).attr("y", function (d) {
                        return yscale(d[1]);
                    }).attr("height", function (d) {
                        return yscale(d[0]) - yscale(d[1]);
                    }).attr("width", function (d) {
                        return newx.bandwidth();
                    });
                })();
            }
        }
    }, {
        key: 'moveHoverline',
        value: function moveHoverline() {
            // Note that the year must be a string here;
            // otherwise it is interpreted as unix time.

            var xpos = this.state.mouseX || this.chart.x(new Date(this.state.date));
            xpos = Math.min(xpos, this.chart.xwidth);
            xpos = Math.max(xpos, 0);

            this.hoverline.attr("x1", xpos).attr("x2", xpos);

            this.svg.layers.veil.attr('x', xpos);
        }

        // Add interaction actions.

    }, {
        key: 'addActions',
        value: function addActions() {
            var that = this;

            function getMouseX(e) {
                var x = void 0;
                // Makes event valid for both touch and mouse devices
                if (e.type === 'touchstart') {
                    x = e.touches[0].pageX;
                } else {
                    // Solves some IE compatibility issues

                    x = e.offsetX || d3.mouse(this)[0];
                }
                return x - that.chart.margin.left;
            }
            function getMouseY(e) {
                // Makes event valid for both touch and mouse devices
                if (e.type === 'touchstart') {
                    return e.touches[0].pageY;
                } else {
                    // Solves some IE compatibility issues
                    return e.offsetY || d3.mouse(this)[1];
                }
            }

            function mousedown_callback(e) {
                e = d3.event;
                e.preventDefault();
                var mouseX = getMouseX(e);
                var dateobj = that.chart.x.invert(mouseX); //.getUTCFullYear()
                var date = dateobj.getMonth() <= 6 ? dateobj.getUTCFullYear() : dateobj.getUTCFullYear() + 1;
                visualbudget.broadcastStateChange({
                    mouseX: mouseX,
                    date: "" + date, // cast to string
                    dragging: true
                });
            }
            function mousemove_callback(e) {
                if (that.state.dragging) {
                    mousedown_callback(e);
                }
            }
            function mouseup_callback(e) {
                e = d3.event;
                e.preventDefault();
                visualbudget.broadcastStateChange({
                    dragging: false
                });
            }
            function mouseout_callback(e) {
                e = d3.event;
                e.preventDefault();
                visualbudget.broadcastStateChange({
                    dragging: false
                });
            }

            this.svg.on('mousedown', mousedown_callback);
            this.svg.on('mousemove', mousemove_callback);
            this.svg.on('mouseup', mouseup_callback);
            // this.svg.on('mouseout',  mouseout_callback); // glitchy.
        }
    }, {
        key: 'isSmooth',
        value: function isSmooth() {
            return this.smooth;
        }
    }]);

    return VbStackedArea;
}(VbChart);
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
 * Tabular view.
 */
var VbTable = function (_VbChart) {
    _inherits(VbTable, _VbChart);

    function VbTable($div, data, config) {
        _classCallCheck(this, VbTable);

        // Cast the data.
        data.dollarAmounts.forEach(function (d) {
            // d.date = Date.parse(d.date);
            d.dollarAmount = +d.dollarAmount;
        });

        // Call super method.

        var _this = _possibleConstructorReturn(this, (VbTable.__proto__ || Object.getPrototypeOf(VbTable)).call(this, $div, data, config));

        _this.$table = $("<div class='vb-table-element'></div>");
        $div.append(_this.$table);

        // Configuration variables.
        var table = _this.table = {};
        table.indent = 25; // indentation width
        table.tableStats = []; // columns to be shown
        // color scales
        table.growthScale = d3.scaleLinear().clamp(true).domain([-10, 10]).range(["rgb(29,118,162)", 'rgb(167, 103, 108)']);
        table.amountScale = d3.scaleLinear().clamp(true).range(["#aaa", "#333"]);
        table.impactScale = d3.scaleLinear().clamp(true).domain([0, 100]).range(["#aaa", "#333"]);
        return _this;
    }

    _createClass(VbTable, [{
        key: "redraw",
        value: function redraw() {
            console.log('Drawing chart ' + this.atts.hash + ' (table).');
            this.initialize(this.$table, this.data);
        }

        // Override the super class's method.

    }, {
        key: "resize",
        value: function resize() {}
        // Do nothing.


        // Overrides the super class's method.

    }, {
        key: "setState",
        value: function setState(newState) {
            // Don't do a full redraw, just update.
            this.state = Object.assign({}, this.state, newState);
            this.update(this.$table, this.data, this.state.date);
        }

        // Update the table data without destroying it.
        // This is used when the year is changed.

    }, {
        key: "update",
        value: function update($container, data, date) {
            var that = this;

            $container.find('.tablerow').not('.tableheader').each(function (i) {
                var node = $(this).data();
                var level = $(this).data('level');
                $(this).html($(that.renderNode(node, level)).html());
            });

            this.alignRows(0);
        }

        /*
        * Initializes table
        *
        *   @param {jQuery obj} $container - table container
        *   @param {node} data - nodes to be displayed
        */

    }, {
        key: "initialize",
        value: function initialize($container, data) {
            var $table = $container;
            var that = this;

            // remove old rows
            $table.find('.tablerow').remove();
            $table.find('.group').remove();

            // load row template
            var tableStats = this.tableStats();

            // display no results message should that be the case
            if (data.length === 0) {
                textRow('No results found.', $table);
                return;
            }

            // render table head
            $table.append(this.renderHeader(tableStats));

            // render all nodes (all search results)
            this.renderNode(data, 0, $table);

            // Open the first group
            $table.children().eq(1).click();
        }

        /*
        *   Aligns columns when the indentation level changes
        */

    }, {
        key: "alignRows",
        value: function alignRows() {
            var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 250;

            var that = this;

            // Assign each row some CSS based on its depth.
            $('.tablerow').each(function () {
                var thisLevel = $(this).data('level') || 0;
                var theCSS = that.getAlignmentCSS(thisLevel);
                $(this).find('.name').animate(theCSS, duration);
            });
        }

        // How does a row's CSS change to align it, based on its depth?

    }, {
        key: "getAlignmentCSS",
        value: function getAlignmentCSS(level) {
            return { 'padding-left': level * 25 };
        }

        /*
        * Defines the statistics to display in the table.
        * Each object of the array has properties "title", "cellClass",
        * and "value".
        */

    }, {
        key: "tableStats",
        value: function tableStats() {
            var that = this;
            return [{
                title: "Name",
                cellClass: "value name long textleft",
                value: function value(node) {

                    var bulletedName = function bulletedName(hasChildren) {
                        return '<div class="bullet' + (hasChildren ? "" : " hidden") + '">&#9656;</div>' + node.name;
                    };

                    return bulletedName(node.children.length);
                },
                cssFunction: function cssFunction(node, level) {
                    return that.getAlignmentCSS(level);
                }
            }, {
                title: "Amount",
                cellClass: "value textright",
                value: function value(node) {
                    return '$' + that.nFormatExact(that.dollarAmountOfCurrentDate(node));
                }
            }, {
                title: "Impact",
                cellClass: "value textright",
                value: function value(node) {
                    var val = that.dollarAmountOfCurrentDate(node);
                    var total = that.dollarAmountOfCurrentDate();
                    return that.formatPercentage(val / total * 100, 0);
                }
            }, {
                title: "Growth",
                cellClass: "value textright",
                value: function value(node) {
                    var date = that.state.date;
                    var percent = that.formatPercentage(100);

                    // Check to see if the previous year existed.
                    // If not, percent will be "N/A";
                    if (that.getFirstDate() <= date - 1) {
                        var cur = that.dollarAmountOfDate(date, node);
                        var prev = that.dollarAmountOfDate(date - 1, node);
                        var pct = (cur - prev) / prev * 100;

                        // If we divided by zero, we'll say 100% growth.
                        if (!pct && pct !== 0) {
                            percent = '';
                        } else {
                            percent = that.formatPercentage(pct);
                        }
                    }

                    return percent;
                }
            }];
        }

        /*
        *  Renders the header based on node data
        */

    }, {
        key: "renderHeader",
        value: function renderHeader(tableStats) {
            var template = '<div class="tablerow tableheader" data-level=0>' + '{{#.}}' + '<div class="{{cellClass}} head">{{title}}</div>' + '{{/.}}' + '</div>';
            return Mustache.render(template, tableStats);
        }

        /*
        *  The template for a table row.
        */

    }, {
        key: "rowTemplate",
        value: function rowTemplate() {
            return '<div class="tablerow datarow"></div>';
        }

        /*
        *   Renders row containing just text (used to display 'No results found' msg)
        *
        *   @param {string} msg - message to be displayed
        *   @param {jQuery obj} table - container
        */

    }, {
        key: "textRow",
        value: function textRow(msg, $table) {
            var template = this.rowTemplate();
            var rendered = $table.append(Mustache.render(template)).children().last();
            // align text to center
            rendered.css({
                'text-align': 'center'
            }).text(msg);
        }

        /*
        *   Renders row based on node data
        *
        *   @param {object} node - current node
        *   @param {int} level - current depth
        *   @param {jquery object} - container to which new row is appended
        *
        *   @return {jquery object} - new row
        */

    }, {
        key: "renderNode",
        value: function renderNode(node, level) {
            var container = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

            // Grab the template
            var template = this.rowTemplate();

            // Render the template.
            var rendered = jQuery(template);
            // let rendered = jQuery(Mustache.render(template,
            //         {hidden: node.children.length ? '' : 'bullet-hidden'}));

            // Only append it to the container if the flag is passed.
            if (container) {
                container.append(rendered);
            }

            // Get the stats.
            var tableStats = this.tableStats();

            // check whether node has children
            rendered.addClass(node.children.length === 0 ? 'atomic' : '');
            rendered.data(node);
            rendered.data('level', level);

            // recreate indentation style based on level
            rendered.css({
                'padding-left': level * 25
            });

            $.each(tableStats, function () {
                // append new cell to row
                var newcell = $('<div class="' + this.cellClass + '"> </div>').appendTo(rendered);

                // text (eg. row title)
                newcell.html(this.value(node));
                if (this.cssFunction) {
                    newcell.css(this.cssFunction(node, level));
                }
            });

            // attach click event 
            rendered.click(this.rowClick(this));

            return rendered;
        }

        /*
        *   Click event for rows
        */

    }, {
        key: "rowClick",
        value: function rowClick(that) {
            return function () {
                var row = $(this);
                var node = row.data();
                // atomic nodes don't need to expand or collapse
                if (row.hasClass('atomic')) return;

                if (row.hasClass('expanded')) {
                    (function () {

                        /*
                         *  Collapse row if expanded
                         */

                        var allChildren = [];
                        var getAllChildren = function getAllChildren(node) {
                            var divs = $(node).data('childDivs');
                            if (divs) {
                                allChildren.push.apply(allChildren, _toConsumableArray(divs));
                                divs.forEach(function (d) {
                                    return getAllChildren(d);
                                });
                            }
                        };
                        getAllChildren(row);

                        var count = 0;
                        var total = allChildren.length;

                        allChildren.forEach(function (d) {
                            return d.fadeOut(300, function () {
                                $(this).remove();
                                count++;
                                if (count == total) {
                                    that.alignRows();
                                }
                            });
                        });

                        row.removeClass('expanded');
                    })();
                } else {

                    /*
                     *  Expand row if collapsed
                     */

                    var childDivs = [];

                    // render children rows
                    for (var i = 0; i < node.children.length; i++) {
                        childDivs.push(that.renderNode(node.children[i], row.data('level') + 1));
                    }
                    childDivs.reverse();

                    row.data('childDivs', childDivs);
                    childDivs.forEach(function (d) {
                        return row.after($(d).hide());
                    });

                    // show children rows
                    that.alignRows();
                    childDivs.forEach(function (d) {
                        return d.fadeIn(300);
                    });

                    row.addClass('expanded');
                }
            };
        }
    }]);

    return VbTable;
}(VbChart);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var VbTreeMap = function (_VbChart) {
    _inherits(VbTreeMap, _VbChart);

    function VbTreeMap($div, data, config) {
        _classCallCheck(this, VbTreeMap);

        // Cast the data.
        data.dollarAmounts.forEach(function (d) {
            // d.date = Date.parse(d.date);
            d.dollarAmount = +d.dollarAmount;
        });

        // Call super method.

        // Set up the SVG.
        var _this = _possibleConstructorReturn(this, (VbTreeMap.__proto__ || Object.getPrototypeOf(VbTreeMap)).call(this, $div, data, config));

        _this.initialize($div, data);
        return _this;
    }

    _createClass(VbTreeMap, [{
        key: 'redraw',
        value: function redraw() {
            console.log('Drawing chart ' + this.atts.hash + ' (treemap).');
            d3.selectAll('#' + this.$div.attr('id') + ' svg g *').remove();
            this.adjustSize();
            this.calculateLayout();
            this.currentLevel = this.display(this.currentData);
            this.open();
        }

        // Resize the chart in accordance with the size of its container div.
        // This is called on initialization and upon window resizing.

    }, {
        key: 'adjustSize',
        value: function adjustSize() {
            var width = this.$div.width();
            var height = this.$div.height();

            // Resize the svg.
            d3.select(this.$div.get(0)).select('svg').attr('width', width).attr('height', height);

            d3.select('#vb-zoom-button').attr('width', width).attr('height', height);

            // Reset the ranges to fit the new div size.
            this.nav.x.range([0, width]);
            this.nav.y.range([0, height]);
        }

        // When a new state is broadcast by a chart this one is interacting with,
        // this function updates the chart accordingly.

    }, {
        key: 'setState',
        value: function setState(newState) {
            var oldDate = this.state.date;
            var newDate = newState.date;

            this.state = Object.assign({}, this.state, newState);

            if (newDate && newDate != oldDate) {
                this.dateIndex = this.getDateIndex(this.state.date);
                this.calculateLayout();
                this.open();
            }
        }

        // Initialize the treemap.

    }, {
        key: 'initialize',
        value: function initialize($div, data) {
            // null for now.
            this.currentLevel = null;

            // Index of the starting date.
            var dateIndex = this.dateIndex = this.getDateIndex(this.state.date);

            // Size of container
            var width = $div.width(),
                height = $div.height();

            var formatNumber = d3.format(",d"),
                transitioning;

            // Create svg
            var nav = this.nav = d3.select($div.get(0)).append("svg").append("g").style("shape-rendering", "crispEdges");

            // Initialize x and y scales
            nav.x = d3.scaleLinear().domain([0, width]);

            nav.y = d3.scaleLinear().domain([0, height]);

            nav.grandparent = nav.append("rect").attr("y", "-20px").attr("class", "grandparent");

            // Create the "zoom out" button
            var p = document.createElement("p");
            p.setAttribute("class", "vb-zoom-button disabled");
            $div.prepend(p);
            d3.select(p).text('Zoom out').on("click", function () {
                nav.grandparent.dispatch('click');
            });

            // Initialize the tooltips.
            var tooltipContent = function tooltipContent(that) {
                return function (d) {
                    var html = "<div class='name'>" + d.data.name + "</div>";
                    var showMyContribution = that.getAttribute('showmycontribution');

                    if (that.state.myTaxBill !== '' && showMyContribution) {

                        // Calculate the user's contribution as well as the
                        // portion of this treemap item paid for by (property) taxes.
                        var total = that.taxAdjustedDollarAmountOfDate(that.state.date);
                        var subTotal = that.taxAdjustedDollarAmountOfDate(that.state.date, d.data);
                        var myBill = that.state.myTaxBill;
                        var myContribution = myBill * (subTotal / total);
                        var pctFundedByTaxes = subTotal / that.dollarAmountOfDate(that.state.date, d.data);
                        pctFundedByTaxes = Math.round(100 * pctFundedByTaxes);

                        // The parenthetical is added only if the query param "taxtype=property" is set
                        // AND (if (the param "showfundedbytaxes" is either set to "all")
                        // or (is set to "fractions" and % funded by taxes is less than one)).

                        // Make sure showFundedByTaxes is set properly; the default is "fractions".
                        var showFundedByTaxes = that.getAttribute('showfundedbytaxes', 'fractions', ['all', 'fractions']);

                        // Now add the note, if.
                        var taxesNote = "";
                        var taxType = that.getAttribute('taxtype');
                        if (taxType && (showFundedByTaxes == "all" || pctFundedByTaxes < 100)) {
                            var taxesType = that.atts.taxtype;
                            taxesNote = "<br/>(" + pctFundedByTaxes + "% is paid for by " + taxesType + " taxes.)";
                        }

                        // Put the HTML all together.
                        html = html + "<div class='description'>Your contribution is " + "$" + myContribution.toFixed(2) + "." + taxesNote + "</div>";
                    }
                    return html;
                };
            };
            this.tip = d3.tip().attr('class', 'd3-tip').offset([-10, 0]).html(tooltipContent(this));
            nav.call(this.tip);

            // Display the treemap.
            // this.currentLevel = this.display(this.currentData);
        }
    }, {
        key: 'calculateLayout',
        value: function calculateLayout() {
            var _this2 = this;

            this.root = d3.hierarchy(this.data, function (d) {
                return d.children;
            }).sum(function (d) {
                return d.children.length ? 0 : d.dollarAmounts[_this2.dateIndex].dollarAmount;
            }).sort(function (a, b) {
                return b.value - a.value;
            });

            // make the treemap
            this.treemap = d3.treemap().tile(d3.treemapResquarify).size([this.$div.width(), this.$div.height()]).padding(0).round(1);

            this.treemap(this.root);
            this.currentData = this.currentData ? this.findHash(this.currentData.data.hash, this.root) : this.root;
            this.state.hash = this.currentData.data.hash;
        }

        /*
        *   Draws and displays a treemap layout from node data
        *
        *   @param {node} d - node where treemap begins (root)
        */

    }, {
        key: 'display',
        value: function display(d) {

            var that = this;
            var nav = this.nav;

            var formatNumber = d3.format(",d"),

            // Flag will be used to avoid overlapping transitions
            transitioning;

            // insert top-level blocks
            var g1 = nav.insert("g", ".grandparent-g").datum(d).attr("class", "depth");

            // add in data
            var g = g1.selectAll("g").data(d.children ? d.children : [d]).enter().append("g");

            // create grandparent zoom-out bar at top
            nav.grandparent.attr('width', '100%').attr('height', '20px').style('fill', '#eaa').datum(d.parent === undefined ? d : d.parent).on("click", function (event) {
                that.zoneClick.call(this, d3.select(this).datum(), true, null, that);
            });

            /* add "childen" class to those with children */
            g.classed("treemap-item", true).filter(function (d) {
                return d.children;
            }).classed("children", true);

            /* transition on child click */
            g.on("click", function (event) {
                that.zoneClick.call(this, d3.select(this).datum(), true, null, that);
            }).each(function () {
                var node = d3.select(this);
                // assign node hash attribute
                node.attr('nodeid', function () {
                    return node.datum().data.hash;
                });
            });

            // draw parent rectangle
            g.append("rect").attr("class", "parent").call(that.rect(that.nav)).style("fill", function (d) {
                return d.data.color;
            }).on('mouseenter', this.tip.show).on('mouseleave', this.tip.hide);

            // recursively draw children rectangles
            function addChilds(d, g) {
                // add child rectangles
                g.selectAll(".child").data(function (d) {
                    return d.children || [d];
                }).enter().append("g").attr("class", "child").append("rect").call(that.rect(that.nav));
            }

            addChilds(d, g);

            // the dateIndex.
            var dateIndex = this.dateIndex;

            // assign label through foreign object
            // foreignobjects allows the use of divs and textwrapping
            g.each(function () {
                var label = d3.select(this).append("foreignObject").call(that.rect(that.nav))
                // .style("background", "#bca")
                .attr("class", "foreignobj").append("xhtml:div").html(function (d) {
                    var title = '<div class="titleLabel">' + d.data.name + '</div>',
                        values = '<div class="valueLabel">' + '$' + that.nFormat(d.value) + '</div>';
                    return title + values;
                }).attr("class", "textdiv").classed("no-label", true);

                // textLabels.call(this); // FIXME
            });

            return g;
        }

        // Open a node.

    }, {
        key: 'open',
        value: function open(transition) {
            // find node with given hash or open root node
            this.zoneClick.call(null, this.currentData, false, transition || 1, this);
        }

        /*
        *   Event triggered on click event in treemap areas
        *
        *   @param {node} d - clicked node data
        *   @param {boolean} click - whether click was triggered
        *   @param {integer} transition - transition duration
        *   @param {obj} that - "this" context for the VbTreeMap object
        */

    }, {
        key: 'zoneClick',
        value: function zoneClick(d, click, transition, that) {
            //destroy popovers on transition (so they don't accidentally stay)
            // $(this).find('div').first().popover('destroy');
            that.tip.hide();

            var nav = that.nav;

            // stop event propagation
            var event = d3.event || window.event || event;
            if (event) {
                event.preventDefault();
            }

            transition = transition || 750;

            // do not expand if another transition is happening
            // or data not defined
            if (nav.transitioning || !d) return;

            // Go back if click happened on the same zone
            if (click && d.data.hash === that.currentData.data.hash) {
                nav.grandparent.dispatch('click');
                return;
            }

            // Enable or disable the zoom button, depending.
            var zoombutton = jQuery(that.$div).find('.vb-zoom-button');
            if (d.data.hash == that.root.data.hash) {
                zoombutton.addClass("disabled");
            } else {
                zoombutton.removeClass("disabled");
            }

            // Reset year
            var dateIndex = that.dateIndex;

            if (d.value === 0) {
                that.zoneClick.call(null, d.parent || that.root.data.hash, 0, that);
                return;
            }

            // Remove old labels
            nav.selectAll('text').remove();

            // Remember currently selected section and year
            that.currentData = d;
            that.state.hash = d.data.hash;
            // visualbudget.broadcastStateChange(that.state);
            // FIXME: the above is causing errors when it occurs before line charts are drawn.

            // Prevent further events from happening while transitioning
            nav.transitioning = true;

            // Initialize transitions
            var g2 = that.display(d);
            var t1 = that.currentLevel.transition().duration(transition);
            var t2 = g2.transition().duration(transition);

            // Update the domain only after entering new elements.
            nav.x.domain([d.x0, d.x1]);
            nav.y.domain([d.y0, d.y1]);

            // Enable anti-aliasing during the transition.
            nav.style("shape-rendering", null);

            // Draw child nodes on top of parent nodes.
            nav.selectAll(".depth").sort(function (a, b) {
                return a.depth - b.depth;
            });

            // Fade-in entering text.
            g2.selectAll(".foreignobj").style("fill-opacity", 0).each(function (d, i) {
                // Determine whether to show the label.
                // The magic number 0.067 was found by testing:
                // on a chart which is 600x300px, the label is shown
                // if the cell size is at least 40x20px.
                var xDomain = nav.x.domain();
                var yDomain = nav.y.domain();
                var xSizeFraction = (d.x1 - d.x0) / (xDomain[1] - xDomain[0]);
                var ySizeFraction = (d.y1 - d.y0) / (yDomain[1] - yDomain[0]);
                if (xSizeFraction > 0.067 && ySizeFraction > 0.067) {
                    d3.select(this).selectAll('.textdiv').classed('no-label', false);
                }
            });

            // Transition to the new view
            t1.style('opacity', 0);
            t1.selectAll(".foreignobj").call(that.rect(nav));
            t2.selectAll(".foreignobj").call(that.rect(nav));
            t1.selectAll("rect").call(that.rect(nav));
            t2.selectAll("rect").call(that.rect(nav));

            // Remove the old node when the transition is finished.
            t1.remove().on("end", function () {
                nav.style("shape-rendering", "crispEdges");
                nav.transitioning = false;
            });

            // update current level
            that.currentLevel = g2;

            // Broadcast the state change so other charts can "dive down" into the data.
            setTimeout(function () {
                visualbudget.broadcastStateChange({
                    hash: d.data.hash
                });
            }, 0);
        }

        /*
        *   Sets SVG rectangle properties based on treemap node values
        *
        *   @param {d3 selection} rect - SVG rectangle
        */

    }, {
        key: 'rect',
        value: function rect(nav) {
            return function (rect) {
                rect.attr("x", function (d) {
                    return nav.x(d.x0);
                }).attr("y", function (d) {
                    return nav.y(d.y0);
                }).attr("width", function (d) {
                    return nav.x(d.x1) - nav.x(d.x0);
                }).attr("height", function (d) {
                    return nav.y(d.y1) - nav.y(d.y0);
                });
            };
        }
    }]);

    return VbTreeMap;
}(VbChart);
'use strict';

/**
 * Define the visualbudget module.
 */
var visualbudget = function (vb, $, d3) {

    /**
     * Initialize each chart.
     */
    vb.initialize = function (callback) {

        // Set callback to an empty function if it's not set
        if (typeof callback === "undefined") {
            callback = function callback() {};
        }

        console.log('Initializing VB charts.');

        // First get the config settings.
        var configURL = $('.vb-chart:first').data('vbConfigUrl');
        $.when($.getJSON(configURL).done(vb.setConfig).fail(function (_, txt, err) {
            console.log("Request Failed: " + txt + ", " + err);
        })).done(function () {
            // Now initialize all charts.
            vb.charts = [];
            var $chartDivs = $('.vb-chart');
            $.when.apply($, $chartDivs.map(vb.tryToInitializeChart)).then(vb.drawAllCharts).then(callback);
        });
    };

    /**
     * Configuration callback.
     */
    vb.setConfig = function (data) {
        vb.config = data;
    };

    /**
     * Try to initialize a chart. This function attempts to read the
     * data from the given url. Upon success, the setupChartObject
     * callback is invoked.
     */
    vb.tryToInitializeChart = function () {
        var $div = $(this);
        var url = $div.data('vbDatasetUrl');
        var urls = $div.data('vbDatasetUrls');

        // Every chart requires a URL except for the 'mytaxbill' component.
        // Comparison charts require two.
        if (url) {
            var jqXHR = $.getJSON(url).done(vb.setupChartObject($div)).fail(function (jqxhr, textStatus, error) {
                var err = textStatus + ", " + error;
                console.log("Request Failed: " + err);
            });
            return jqXHR;
        } else if (urls) {
            // If it is a comparison chart and requires multiple datasets.
            urls = urls.split(',');
            var requests = urls.map(function (url) {
                return $.getJSON(url);
            });
            $.when.apply(this, requests).then(function () {
                // Each response is an array: [ data, statusText, jqXHR ]
                var dataArray = [];

                for (var _len = arguments.length, responses = Array(_len), _key = 0; _key < _len; _key++) {
                    responses[_key] = arguments[_key];
                }

                for (var i = 0; i < responses.length; i++) {
                    dataArray.push(responses[i][0]);
                }
                vb.setupChartObject($div)(dataArray);
            });
            return requests;
        } else {
            // So catch that case, and don't try to load any data for it.
            // FIXME: This is hacky. Is there a better way?
            if ($div.data('vbVis') == 'mytaxbill') {
                vb.setupChartObject($div)([]);
            }
        }
    };

    /**
     * Returns a callback to set up a new chart, with the jquery
     * selector of the chart div element in scope.
     */
    vb.setupChartObject = function ($div) {
        return function (data) {

            var newChart;
            var config = vb.config;

            switch ($div.data('vbVis')) {
                case 'linechart':
                    newChart = new VbLineChart($div, data, config);
                    break;

                case 'stackedarea':
                    newChart = new VbStackedArea($div, data, config);
                    break;

                case 'comparisontime':
                    newChart = new VbComparisonTime($div, data, config);
                    break;

                case 'treemap':
                    newChart = new VbTreeMap($div, data, config);
                    break;

                case 'legend':
                    newChart = new VbLegend($div, data, config);
                    break;

                case 'table':
                    newChart = new VbTable($div, data, config);
                    break;

                case 'metric':
                    newChart = new VbMetric($div, data, config);
                    break;

                case 'mytaxbill':
                    newChart = new VbMyTaxBill($div, config);
                    break;

                default:
                    console.log('VB error: Unrecognized chart type.');
                    return;
            }

            vb.charts.push(newChart);
            console.log('Added chart ' + newChart.atts.hash + ' to queue.');
        };
    };

    /**
     * Redraw all charts on the page.
     */
    vb.drawAllCharts = function () {
        vb.charts.forEach(function (chart, i, array) {
            chart.redraw();
        });
    };

    vb.broadcastStateChange = function (state) {
        for (var i = 0; i < vb.charts.length; i++) {
            vb.charts[i].setState(state);
        }
    };

    /**
     * Search for a chart by its hash. Returns null if no matching chart is found.
     */
    vb.getChart = function (hash) {
        var match = null;

        for (var i = 0; i < vb.charts.length; i++) {
            if (vb.charts[i].atts.hash == hash) {
                match = vb.charts[i];
                break;
            }
        }

        return match;
    };

    return vb;
}(visualbudget || {}, jQuery, d3);

/**
 * Kick it off.
 */
var $ = jQuery;
(function (vb, $) {
    $(document).ready(function () {
        'use strict';

        vb.initialize();
    });
})(visualbudget, jQuery);
'use strict';

// d3.tip
// Copyright (c) 2013 Justin Palmer
// ES6 / D3 v4 Adaption Copyright (c) 2016 Constantin Gavrilete
// Removal of ES6 for D3 v4 Adaption Copyright (c) 2016 David Gotz
//
// Tooltips for d3.js SVG visualizations

d3.functor = function functor(v) {
  return typeof v === "function" ? v : function () {
    return v;
  };
};

d3.tip = function () {

  var direction = d3_tip_direction,
      offset = d3_tip_offset,
      html = d3_tip_html,
      node = initNode(),
      svg = null,
      point = null,
      target = null;

  function tip(vis) {
    svg = getSVGNode(vis);
    point = svg.createSVGPoint();
    document.body.appendChild(node);
  }

  // Public - show the tooltip on the screen
  //
  // Returns a tip
  tip.show = function () {
    var args = Array.prototype.slice.call(arguments);
    if (args[args.length - 1] instanceof SVGElement) target = args.pop();

    var content = html.apply(this, args),
        poffset = offset.apply(this, args),
        dir = direction.apply(this, args),
        nodel = getNodeEl(),
        i = directions.length,
        coords,
        scrollTop = document.documentElement.scrollTop || document.body.scrollTop,
        scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;

    nodel.html(content).style('position', 'absolute').style('opacity', 1).style('pointer-events', 'all');

    while (i--) {
      nodel.classed(directions[i], false);
    }coords = direction_callbacks[dir].apply(this);
    nodel.classed(dir, true).style('top', coords.top + poffset[0] + scrollTop + 'px').style('left', coords.left + poffset[1] + scrollLeft + 'px');

    return tip;
  };

  // Public - hide the tooltip
  //
  // Returns a tip
  tip.hide = function () {
    var nodel = getNodeEl();
    nodel.style('opacity', 0).style('pointer-events', 'none');
    return tip;
  };

  // Public: Proxy attr calls to the d3 tip container.  Sets or gets attribute value.
  //
  // n - name of the attribute
  // v - value of the attribute
  //
  // Returns tip or attribute value
  tip.attr = function (n, v) {
    if (arguments.length < 2 && typeof n === 'string') {
      return getNodeEl().attr(n);
    } else {
      var args = Array.prototype.slice.call(arguments);
      d3.selection.prototype.attr.apply(getNodeEl(), args);
    }

    return tip;
  };

  // Public: Proxy style calls to the d3 tip container.  Sets or gets a style value.
  //
  // n - name of the property
  // v - value of the property
  //
  // Returns tip or style property value
  tip.style = function (n, v) {
    // debugger;
    if (arguments.length < 2 && typeof n === 'string') {
      return getNodeEl().style(n);
    } else {
      var args = Array.prototype.slice.call(arguments);
      if (args.length === 1) {
        var styles = args[0];
        Object.keys(styles).forEach(function (key) {
          return d3.selection.prototype.style.apply(getNodeEl(), [key, styles[key]]);
        });
      }
    }

    return tip;
  };

  // Public: Set or get the direction of the tooltip
  //
  // v - One of n(north), s(south), e(east), or w(west), nw(northwest),
  //     sw(southwest), ne(northeast) or se(southeast)
  //
  // Returns tip or direction
  tip.direction = function (v) {
    if (!arguments.length) return direction;
    direction = v == null ? v : d3.functor(v);

    return tip;
  };

  // Public: Sets or gets the offset of the tip
  //
  // v - Array of [x, y] offset
  //
  // Returns offset or
  tip.offset = function (v) {
    if (!arguments.length) return offset;
    offset = v == null ? v : d3.functor(v);

    return tip;
  };

  // Public: sets or gets the html value of the tooltip
  //
  // v - String value of the tip
  //
  // Returns html value or tip
  tip.html = function (v) {
    if (!arguments.length) return html;
    html = v == null ? v : d3.functor(v);

    return tip;
  };

  // Public: destroys the tooltip and removes it from the DOM
  //
  // Returns a tip
  tip.destroy = function () {
    if (node) {
      getNodeEl().remove();
      node = null;
    }
    return tip;
  };

  function d3_tip_direction() {
    return 'n';
  }
  function d3_tip_offset() {
    return [0, 0];
  }
  function d3_tip_html() {
    return ' ';
  }

  var direction_callbacks = {
    n: direction_n,
    s: direction_s,
    e: direction_e,
    w: direction_w,
    nw: direction_nw,
    ne: direction_ne,
    sw: direction_sw,
    se: direction_se
  };

  var directions = Object.keys(direction_callbacks);

  function direction_n() {
    var bbox = getScreenBBox();
    return {
      top: bbox.n.y - node.offsetHeight,
      left: bbox.n.x - node.offsetWidth / 2
    };
  }

  function direction_s() {
    var bbox = getScreenBBox();
    return {
      top: bbox.s.y,
      left: bbox.s.x - node.offsetWidth / 2
    };
  }

  function direction_e() {
    var bbox = getScreenBBox();
    return {
      top: bbox.e.y - node.offsetHeight / 2,
      left: bbox.e.x
    };
  }

  function direction_w() {
    var bbox = getScreenBBox();
    return {
      top: bbox.w.y - node.offsetHeight / 2,
      left: bbox.w.x - node.offsetWidth
    };
  }

  function direction_nw() {
    var bbox = getScreenBBox();
    return {
      top: bbox.nw.y - node.offsetHeight,
      left: bbox.nw.x - node.offsetWidth
    };
  }

  function direction_ne() {
    var bbox = getScreenBBox();
    return {
      top: bbox.ne.y - node.offsetHeight,
      left: bbox.ne.x
    };
  }

  function direction_sw() {
    var bbox = getScreenBBox();
    return {
      top: bbox.sw.y,
      left: bbox.sw.x - node.offsetWidth
    };
  }

  function direction_se() {
    var bbox = getScreenBBox();
    return {
      top: bbox.se.y,
      left: bbox.e.x
    };
  }

  function initNode() {
    var node = d3.select(document.createElement('div'));
    node.style('position', 'absolute').style('top', 0).style('opacity', 0).style('pointer-events', 'none').style('box-sizing', 'border-box');

    return node.node();
  }

  function getSVGNode(el) {
    el = el.node();
    if (el.tagName.toLowerCase() === 'svg') return el;

    return el.ownerSVGElement;
  }

  function getNodeEl() {
    if (node === null) {
      node = initNode();
      // re-add node to DOM
      document.body.appendChild(node);
    };
    return d3.select(node);
  }

  // Private - gets the screen coordinates of a shape
  //
  // Given a shape on the screen, will return an SVGPoint for the directions
  // n(north), s(south), e(east), w(west), ne(northeast), se(southeast), nw(northwest),
  // sw(southwest).
  //
  //    +-+-+
  //    |   |
  //    +   +
  //    |   |
  //    +-+-+
  //
  // Returns an Object {n, s, e, w, nw, sw, ne, se}
  function getScreenBBox() {
    var targetel = target || d3.event.target;

    while ('undefined' === typeof targetel.getScreenCTM && 'undefined' === targetel.parentNode) {
      targetel = targetel.parentNode;
    }

    var bbox = {},
        matrix = targetel.getScreenCTM(),
        tbbox = targetel.getBBox(),
        width = tbbox.width,
        height = tbbox.height,
        x = tbbox.x,
        y = tbbox.y;

    point.x = x;
    point.y = y;
    bbox.nw = point.matrixTransform(matrix);
    point.x += width;
    bbox.ne = point.matrixTransform(matrix);
    point.y += height;
    bbox.se = point.matrixTransform(matrix);
    point.x -= width;
    bbox.sw = point.matrixTransform(matrix);
    point.y -= height / 2;
    bbox.w = point.matrixTransform(matrix);
    point.x += width;
    bbox.e = point.matrixTransform(matrix);
    point.x -= width / 2;
    point.y -= height / 2;
    bbox.n = point.matrixTransform(matrix);
    point.y += height;
    bbox.s = point.matrixTransform(matrix);

    return bbox;
  }

  return tip;
};
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */

/*global define: false Mustache: true*/

(function defineMustache(global, factory) {
  if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && exports && typeof exports.nodeName !== 'string') {
    factory(exports); // CommonJS
  } else if (typeof define === 'function' && define.amd) {
    define(['exports'], factory); // AMD
  } else {
    global.Mustache = {};
    factory(global.Mustache); // script, wsh, asp
  }
})(window, function mustacheFactory(mustache) {

  var objectToString = Object.prototype.toString;
  var isArray = Array.isArray || function isArrayPolyfill(object) {
    return objectToString.call(object) === '[object Array]';
  };

  function isFunction(object) {
    return typeof object === 'function';
  }

  /**
   * More correct typeof string handling array
   * which normally returns typeof 'object'
   */
  function typeStr(obj) {
    return isArray(obj) ? 'array' : typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
  }

  function escapeRegExp(string) {
    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
  }

  /**
   * Null safe way of checking whether or not an object,
   * including its prototype, has a given property
   */
  function hasProperty(obj, propName) {
    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && propName in obj;
  }

  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
  // See https://github.com/janl/mustache.js/issues/189
  var regExpTest = RegExp.prototype.test;
  function testRegExp(re, string) {
    return regExpTest.call(re, string);
  }

  var nonSpaceRe = /\S/;
  function isWhitespace(string) {
    return !testRegExp(nonSpaceRe, string);
  }

  var entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;',
    '`': '&#x60;',
    '=': '&#x3D;'
  };

  function escapeHtml(string) {
    return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
      return entityMap[s];
    });
  }

  var whiteRe = /\s*/;
  var spaceRe = /\s+/;
  var equalsRe = /\s*=/;
  var curlyRe = /\s*\}/;
  var tagRe = /#|\^|\/|>|\{|&|=|!/;

  /**
   * Breaks up the given `template` string into a tree of tokens. If the `tags`
   * argument is given here it must be an array with two string values: the
   * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
   * course, the default is to use mustaches (i.e. mustache.tags).
   *
   * A token is an array with at least 4 elements. The first element is the
   * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
   * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
   * all text that appears outside a symbol this element is "text".
   *
   * The second element of a token is its "value". For mustache tags this is
   * whatever else was inside the tag besides the opening symbol. For text tokens
   * this is the text itself.
   *
   * The third and fourth elements of the token are the start and end indices,
   * respectively, of the token in the original template.
   *
   * Tokens that are the root node of a subtree contain two more elements: 1) an
   * array of tokens in the subtree and 2) the index in the original template at
   * which the closing tag for that section begins.
   */
  function parseTemplate(template, tags) {
    if (!template) return [];

    var sections = []; // Stack to hold section tokens
    var tokens = []; // Buffer to hold the tokens
    var spaces = []; // Indices of whitespace tokens on the current line
    var hasTag = false; // Is there a {{tag}} on the current line?
    var nonSpace = false; // Is there a non-space char on the current line?

    // Strips all whitespace tokens array for the current line
    // if there was a {{#tag}} on it and otherwise only space.
    function stripSpace() {
      if (hasTag && !nonSpace) {
        while (spaces.length) {
          delete tokens[spaces.pop()];
        }
      } else {
        spaces = [];
      }

      hasTag = false;
      nonSpace = false;
    }

    var openingTagRe, closingTagRe, closingCurlyRe;
    function compileTags(tagsToCompile) {
      if (typeof tagsToCompile === 'string') tagsToCompile = tagsToCompile.split(spaceRe, 2);

      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2) throw new Error('Invalid tags: ' + tagsToCompile);

      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\s*');
      closingTagRe = new RegExp('\\s*' + escapeRegExp(tagsToCompile[1]));
      closingCurlyRe = new RegExp('\\s*' + escapeRegExp('}' + tagsToCompile[1]));
    }

    compileTags(tags || mustache.tags);

    var scanner = new Scanner(template);

    var start, type, value, chr, token, openSection;
    while (!scanner.eos()) {
      start = scanner.pos;

      // Match any text between tags.
      value = scanner.scanUntil(openingTagRe);

      if (value) {
        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
          chr = value.charAt(i);

          if (isWhitespace(chr)) {
            spaces.push(tokens.length);
          } else {
            nonSpace = true;
          }

          tokens.push(['text', chr, start, start + 1]);
          start += 1;

          // Check for whitespace on the current line.
          if (chr === '\n') stripSpace();
        }
      }

      // Match the opening tag.
      if (!scanner.scan(openingTagRe)) break;

      hasTag = true;

      // Get the tag type.
      type = scanner.scan(tagRe) || 'name';
      scanner.scan(whiteRe);

      // Get the tag value.
      if (type === '=') {
        value = scanner.scanUntil(equalsRe);
        scanner.scan(equalsRe);
        scanner.scanUntil(closingTagRe);
      } else if (type === '{') {
        value = scanner.scanUntil(closingCurlyRe);
        scanner.scan(curlyRe);
        scanner.scanUntil(closingTagRe);
        type = '&';
      } else {
        value = scanner.scanUntil(closingTagRe);
      }

      // Match the closing tag.
      if (!scanner.scan(closingTagRe)) throw new Error('Unclosed tag at ' + scanner.pos);

      token = [type, value, start, scanner.pos];
      tokens.push(token);

      if (type === '#' || type === '^') {
        sections.push(token);
      } else if (type === '/') {
        // Check section nesting.
        openSection = sections.pop();

        if (!openSection) throw new Error('Unopened section "' + value + '" at ' + start);

        if (openSection[1] !== value) throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
      } else if (type === 'name' || type === '{' || type === '&') {
        nonSpace = true;
      } else if (type === '=') {
        // Set the tags for the next time around.
        compileTags(value);
      }
    }

    // Make sure there are no open sections when we're done.
    openSection = sections.pop();

    if (openSection) throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);

    return nestTokens(squashTokens(tokens));
  }

  /**
   * Combines the values of consecutive text tokens in the given `tokens` array
   * to a single token.
   */
  function squashTokens(tokens) {
    var squashedTokens = [];

    var token, lastToken;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      if (token) {
        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
          lastToken[1] += token[1];
          lastToken[3] = token[3];
        } else {
          squashedTokens.push(token);
          lastToken = token;
        }
      }
    }

    return squashedTokens;
  }

  /**
   * Forms the given array of `tokens` into a nested tree structure where
   * tokens that represent a section have two additional items: 1) an array of
   * all tokens that appear in that section and 2) the index in the original
   * template that represents the end of that section.
   */
  function nestTokens(tokens) {
    var nestedTokens = [];
    var collector = nestedTokens;
    var sections = [];

    var token, section;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      switch (token[0]) {
        case '#':
        case '^':
          collector.push(token);
          sections.push(token);
          collector = token[4] = [];
          break;
        case '/':
          section = sections.pop();
          section[5] = token[2];
          collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
          break;
        default:
          collector.push(token);
      }
    }

    return nestedTokens;
  }

  /**
   * A simple string scanner that is used by the template parser to find
   * tokens in template strings.
   */
  function Scanner(string) {
    this.string = string;
    this.tail = string;
    this.pos = 0;
  }

  /**
   * Returns `true` if the tail is empty (end of string).
   */
  Scanner.prototype.eos = function eos() {
    return this.tail === '';
  };

  /**
   * Tries to match the given regular expression at the current position.
   * Returns the matched text if it can match, the empty string otherwise.
   */
  Scanner.prototype.scan = function scan(re) {
    var match = this.tail.match(re);

    if (!match || match.index !== 0) return '';

    var string = match[0];

    this.tail = this.tail.substring(string.length);
    this.pos += string.length;

    return string;
  };

  /**
   * Skips all text until the given regular expression can be matched. Returns
   * the skipped string, which is the entire tail if no match can be made.
   */
  Scanner.prototype.scanUntil = function scanUntil(re) {
    var index = this.tail.search(re),
        match;

    switch (index) {
      case -1:
        match = this.tail;
        this.tail = '';
        break;
      case 0:
        match = '';
        break;
      default:
        match = this.tail.substring(0, index);
        this.tail = this.tail.substring(index);
    }

    this.pos += match.length;

    return match;
  };

  /**
   * Represents a rendering context by wrapping a view object and
   * maintaining a reference to the parent context.
   */
  function Context(view, parentContext) {
    this.view = view;
    this.cache = { '.': this.view };
    this.parent = parentContext;
  }

  /**
   * Creates a new context using the given view with this context
   * as the parent.
   */
  Context.prototype.push = function push(view) {
    return new Context(view, this);
  };

  /**
   * Returns the value of the given name in this context, traversing
   * up the context hierarchy if the value is absent in this context's view.
   */
  Context.prototype.lookup = function lookup(name) {
    var cache = this.cache;

    var value;
    if (cache.hasOwnProperty(name)) {
      value = cache[name];
    } else {
      var context = this,
          names,
          index,
          lookupHit = false;

      while (context) {
        if (name.indexOf('.') > 0) {
          value = context.view;
          names = name.split('.');
          index = 0;

          /**
           * Using the dot notion path in `name`, we descend through the
           * nested objects.
           *
           * To be certain that the lookup has been successful, we have to
           * check if the last object in the path actually has the property
           * we are looking for. We store the result in `lookupHit`.
           *
           * This is specially necessary for when the value has been set to
           * `undefined` and we want to avoid looking up parent contexts.
           **/
          while (value != null && index < names.length) {
            if (index === names.length - 1) lookupHit = hasProperty(value, names[index]);

            value = value[names[index++]];
          }
        } else {
          value = context.view[name];
          lookupHit = hasProperty(context.view, name);
        }

        if (lookupHit) break;

        context = context.parent;
      }

      cache[name] = value;
    }

    if (isFunction(value)) value = value.call(this.view);

    return value;
  };

  /**
   * A Writer knows how to take a stream of tokens and render them to a
   * string, given a context. It also maintains a cache of templates to
   * avoid the need to parse the same template twice.
   */
  function Writer() {
    this.cache = {};
  }

  /**
   * Clears all cached templates in this writer.
   */
  Writer.prototype.clearCache = function clearCache() {
    this.cache = {};
  };

  /**
   * Parses and caches the given `template` and returns the array of tokens
   * that is generated from the parse.
   */
  Writer.prototype.parse = function parse(template, tags) {
    var cache = this.cache;
    var tokens = cache[template];

    if (tokens == null) tokens = cache[template] = parseTemplate(template, tags);

    return tokens;
  };

  /**
   * High-level method that is used to render the given `template` with
   * the given `view`.
   *
   * The optional `partials` argument may be an object that contains the
   * names and templates of partials that are used in the template. It may
   * also be a function that is used to load partial templates on the fly
   * that takes a single argument: the name of the partial.
   */
  Writer.prototype.render = function render(template, view, partials) {
    var tokens = this.parse(template);
    var context = view instanceof Context ? view : new Context(view);
    return this.renderTokens(tokens, context, partials, template);
  };

  /**
   * Low-level method that renders the given array of `tokens` using
   * the given `context` and `partials`.
   *
   * Note: The `originalTemplate` is only ever used to extract the portion
   * of the original template that was contained in a higher-order section.
   * If the template doesn't use higher-order sections, this argument may
   * be omitted.
   */
  Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate) {
    var buffer = '';

    var token, symbol, value;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      value = undefined;
      token = tokens[i];
      symbol = token[0];

      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);else if (symbol === '>') value = this.renderPartial(token, context, partials, originalTemplate);else if (symbol === '&') value = this.unescapedValue(token, context);else if (symbol === 'name') value = this.escapedValue(token, context);else if (symbol === 'text') value = this.rawValue(token);

      if (value !== undefined) buffer += value;
    }

    return buffer;
  };

  Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate) {
    var self = this;
    var buffer = '';
    var value = context.lookup(token[1]);

    // This function is used to render an arbitrary template
    // in the current context by higher-order sections.
    function subRender(template) {
      return self.render(template, context, partials);
    }

    if (!value) return;

    if (isArray(value)) {
      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);
      }
    } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' || typeof value === 'string' || typeof value === 'number') {
      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);
    } else if (isFunction(value)) {
      if (typeof originalTemplate !== 'string') throw new Error('Cannot use higher-order sections without the original template');

      // Extract the portion of the original template that the section contains.
      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);

      if (value != null) buffer += value;
    } else {
      buffer += this.renderTokens(token[4], context, partials, originalTemplate);
    }
    return buffer;
  };

  Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate) {
    var value = context.lookup(token[1]);

    // Use JavaScript's definition of falsy. Include empty arrays.
    // See https://github.com/janl/mustache.js/issues/186
    if (!value || isArray(value) && value.length === 0) return this.renderTokens(token[4], context, partials, originalTemplate);
  };

  Writer.prototype.renderPartial = function renderPartial(token, context, partials) {
    if (!partials) return;

    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
    if (value != null) return this.renderTokens(this.parse(value), context, partials, value);
  };

  Writer.prototype.unescapedValue = function unescapedValue(token, context) {
    var value = context.lookup(token[1]);
    if (value != null) return value;
  };

  Writer.prototype.escapedValue = function escapedValue(token, context) {
    var value = context.lookup(token[1]);
    if (value != null) return mustache.escape(value);
  };

  Writer.prototype.rawValue = function rawValue(token) {
    return token[1];
  };

  mustache.name = 'mustache.js';
  mustache.version = '2.3.0';
  mustache.tags = ['{{', '}}'];

  // All high-level mustache.* functions use this writer.
  var defaultWriter = new Writer();

  /**
   * Clears all cached templates in the default writer.
   */
  mustache.clearCache = function clearCache() {
    return defaultWriter.clearCache();
  };

  /**
   * Parses and caches the given template in the default writer and returns the
   * array of tokens it contains. Doing this ahead of time avoids the need to
   * parse templates on the fly as they are rendered.
   */
  mustache.parse = function parse(template, tags) {
    return defaultWriter.parse(template, tags);
  };

  /**
   * Renders the `template` with the given `view` and `partials` using the
   * default writer.
   */
  mustache.render = function render(template, view, partials) {
    if (typeof template !== 'string') {
      throw new TypeError('Invalid template! Template should be a "string" ' + 'but "' + typeStr(template) + '" was given as the first ' + 'argument for mustache#render(template, view, partials)');
    }

    return defaultWriter.render(template, view, partials);
  };

  // This is here for backwards compatibility with 0.4.x.,
  /*eslint-disable */ // eslint wants camel cased function name
  mustache.to_html = function to_html(template, view, partials, send) {
    /*eslint-enable*/

    var result = mustache.render(template, view, partials);

    if (isFunction(send)) {
      send(result);
    } else {
      return result;
    }
  };

  // Export the escaping function so that the user may override it.
  // See https://github.com/janl/mustache.js/issues/244
  mustache.escape = escapeHtml;

  // Export these mainly for testing, but also for advanced usage.
  mustache.Scanner = Scanner;
  mustache.Context = Context;
  mustache.Writer = Writer;

  return mustache;
});